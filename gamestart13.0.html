<!DOCTYPE html><html lang="zh"><head><meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline' 'unsafe-eval' data: blob: https://cdnjs.cloudflare.com https://cdn.jsdelivr.net https://code.jquery.com https://unpkg.com https://d3js.org https://threejs.org https://cdn.plot.ly https://stackpath.bootstrapcdn.com https://maps.googleapis.com https://cdn.tailwindcss.com https://ajax.googleapis.com https://kit.fontawesome.com https://cdn.datatables.net https://maxcdn.bootstrapcdn.com https://code.highcharts.com https://tako-static-assets-production.s3.amazonaws.com https://www.youtube.com https://fonts.googleapis.com https://fonts.gstatic.com https://pfst.cf2.poecdn.net https://puc.poecdn.net https://i.imgur.com https://wikimedia.org https://*.icons8.com https://*.giphy.com https://picsum.photos https://images.unsplash.com; frame-src 'self' https://www.youtube.com https://trytako.com; child-src 'self'; manifest-src 'self'; worker-src 'self'; upgrade-insecure-requests; block-all-mixed-content;">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>茶茶乐淘金记Ⅱ：深海</title>
    <style>
        :root {
            --bg-color: #0f1631;
            --text-color: #ffffff;
            --ui-bg: rgba(0, 0, 0, 0.7);
            --primary-color: #ff5a5f;
        }

        .dark {
            --bg-color: #030712;
            --text-color: #e2e8f0;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            padding: 20px;
            overflow: hidden;
        }

        #game-container {
            position: relative;
            max-width: 100%;
        }

        canvas {
            display: block;
            margin: 0 auto;
            background-color: #030712;
            max-width: 100%;
            height: auto;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            margin-top: 20px;
            width: 100%;
            max-width: 600px;
        }

        .touch-button {
            background-color: var(--ui-bg);
            border: 2px solid var(--primary-color);
            color: var(--text-color);
            padding: 15px 20px;
            border-radius: 50%;
            font-size: 18px;
            touch-action: manipulation;
            user-select: none;
            outline: none;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 60px;
            height: 60px;
        }

        .touch-button:active {
            background-color: var(--primary-color);
        }

        .instructions {
            margin-top: 20px;
            background-color: var(--ui-bg);
            padding: 15px;
            border-radius: 8px;
            max-width: 600px;
            text-align: center;
            font-size: 14px;
        }

        .key {
            background: var(--primary-color);
            color: white;
            padding: 2px 6px;
            border-radius: 4px;
            font-weight: bold;
            margin: 0 2px;
        }

        @media (max-width: 600px) {
            .touch-button {
                width: 50px;
                height: 50px;
                font-size: 16px;
            }
        }

        @media (min-width: 769px) {
            .touch-controls {
                display: none;
            }
        }

        .touch-controls {
            position: fixed;
            bottom: 10px;
            width: 100%;
            display: flex;
            justify-content: space-between;
            pointer-events: none;
            z-index: 100;
        }

        #joystick-area {
            position: relative;
            width: 120px;
            height: 120px;
            border-radius: 50%;
            background-color: rgba(0, 0, 0, 0.2);
            border: 2px solid rgba(20, 40, 69, 255);
            margin-left: 10px;
            touch-action: none;
            pointer-events: auto;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
        }

        #joystick {
            position: absolute;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background-color: rgba(20, 40, 69, 255);
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.3);
        }

        #jump-button {
            width: 100px;
            height: 100px;
            border-radius: 50%;
            background-color: rgba(20, 40, 69, 255);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 18px;
            font-weight: bold;
            margin-right: 10px;
            touch-action: none;
            pointer-events: auto;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
            transition: all 0.1s ease;
            position: relative;
            overflow: hidden;
        }
        
        /* 跳跃按钮按下效果 */
        #jump-button.active {
            background-color: rgba(40, 80, 130, 255);
            transform: scale(0.9);
            box-shadow: 0 0 15px rgba(80, 140, 255, 0.7);
        }
        
        
        #jump-button.active::after {
            animation: ripple 0.4s ease-out;
        }
        
        @keyframes ripple {
            0% {
                transform: scale(0);
                opacity: 0;
            }
            30% {
                transform: scale(1);
                opacity: 1;
            }
            100% {
                transform: scale(1.5);
                opacity: 0;
            }
        }
        
        @media (max-width: 600px) {
            .touch-button {
                width: 50px;
                height: 50px;
                font-size: 16px;
            }
        }

        @media (min-width: 769px) {
            .touch-controls {
                display: none;
            }
        }
        
        @media (orientation: portrait) {
            .touch-controls {
                display: none;
            }
            
            #game-container {
                max-width: 95vw;
            }
        }
        
        @media (orientation: landscape) and (max-width: 768px) {
            .touch-controls {
                display: flex;
            }
            .controls {
                display: none;
            }
            
            body {
                padding: 0;
                margin: 0;
                overflow: hidden;
                background-color: #000;
                display: flex;
                align-items: center;
                justify-content: center;
                width: 100vw;
                height: 100vh;
            }
            
            #game-container {
                width: 100%;
                height: 100%;
                margin: 0;
                padding: 0;
                display: flex;
                align-items: center;
                justify-content: center;
                position: relative;
            }
            
            canvas {
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                max-width: 100%;
                max-height: 100%;
                object-fit: contain;
            }
            
            .instructions {
                display: none;
            }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="gameCanvas" width="1920" height="600"></canvas>
    </div>

    <div class="instructions">
        <p>键盘控制: <span class="key">A</span> / <span class="key">←</span> 左移, 
           <span class="key">D</span> / <span class="key">→</span> 右移, 
           <span class="key">W</span> / <span class="key">↑</span> 跳跃</p>
    </div>

    <div class="touch-controls controls">
        <button id="leftBtn" class="touch-button">←</button>
        <button id="jumpBtn" class="touch-button">↑</button>
        <button id="rightBtn" class="touch-button">→</button>
    </div>

    <!-- 添加横屏触控界面 -->
    <div class="touch-controls">
        <div id="joystick-area">
            <div id="joystick"></div>
        </div>
        <div id="jump-button">跳</div>
    </div>

    <script>
        // 检测暗黑模式
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            document.documentElement.classList.add('dark');
        }
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
            if (event.matches) {
                document.documentElement.classList.add('dark');
            } else {
                document.documentElement.classList.remove('dark');
            }
        });

        // 游戏主程序
        (function() {
            // 游戏画布设置
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');
            
            // 获取触摸控制按钮
            const leftBtn = document.getElementById('leftBtn');
            const rightBtn = document.getElementById('rightBtn');
            const jumpBtn = document.getElementById('jumpBtn');

            // 横屏触控控件
            const joystickArea = document.getElementById('joystick-area');
            const joystick = document.getElementById('joystick');
            const jumpButton = document.getElementById('jump-button');
            
            // 摇杆变量
            let joystickActive = false;
            let joystickOrigin = { x: 0, y: 0 };
            let joystickPosition = { x: 0, y: 0 };
            const joystickLimit = 25; // 调整为新摇杆尺寸的一半减少一些余量
            
            // 初始化摇杆位置
            function resetJoystick() {
                joystick.style.transform = 'translate(-50%, -50%)';
                joystickPosition = { x: 0, y: 0 };
                gameState.keys.left = false;
                gameState.keys.right = false;
            }
            
            // 摇杆触摸开始
            joystickArea.addEventListener('touchstart', function(e) {
                const rect = joystickArea.getBoundingClientRect();
                joystickOrigin = {
                    x: rect.left + rect.width / 2,
                    y: rect.top + rect.height / 2
                };
                joystickActive = true;
                updateJoystickPosition(e.touches[0].clientX, e.touches[0].clientY);
                e.preventDefault();
            });
            
            // 摇杆触摸移动
            joystickArea.addEventListener('touchmove', function(e) {
                if (joystickActive) {
                    updateJoystickPosition(e.touches[0].clientX, e.touches[0].clientY);
                    e.preventDefault();
                }
            });
            
            // 摇杆触摸结束
            joystickArea.addEventListener('touchend', function(e) {
                joystickActive = false;
                resetJoystick();
                e.preventDefault();
            });
            
            // 摇杆触摸取消
            joystickArea.addEventListener('touchcancel', function(e) {
                joystickActive = false;
                resetJoystick();
                e.preventDefault();
            });
            
            // 更新摇杆位置
            function updateJoystickPosition(touchX, touchY) {
                // 计算触摸点与摇杆原点的偏移量
                let offsetX = touchX - joystickOrigin.x;
                let offsetY = touchY - joystickOrigin.y;
                
                // 计算距离和角度
                const distance = Math.sqrt(offsetX * offsetX + offsetY * offsetY);
                
                // 缩小摇杆限制范围，与摇杆尺寸匹配
                const joystickLimit = 25; // 调整为新摇杆尺寸的一半减少一些余量
                
                // 限制摇杆在范围内
                if (distance > joystickLimit) {
                    offsetX = (offsetX / distance) * joystickLimit;
                    offsetY = (offsetY / distance) * joystickLimit;
                }
                
                // 更新摇杆位置
                joystick.style.transform = `translate(calc(-50% + ${offsetX}px), calc(-50% + ${offsetY}px))`;
                joystickPosition = { x: offsetX, y: offsetY };
                
                // 更新方向键状态 - 调整敏感度阈值
                gameState.keys.left = offsetX < -10;
                gameState.keys.right = offsetX > 10;
            }
            
            // 跳跃按钮事件
            jumpButton.addEventListener('touchstart', function(e) {
                gameState.keys.jump = true;
                
                // 添加按钮按下效果
                jumpButton.classList.add('active');
                
                // 添加触觉反馈（如果支持）
                if (window.navigator && window.navigator.vibrate) {
                    navigator.vibrate(15); // 短暂振动15毫秒
                }
                
                e.preventDefault();
            });
            
            jumpButton.addEventListener('touchend', function(e) {
                gameState.keys.jump = false;
                
                // 移除按钮按下效果
                jumpButton.classList.remove('active');
                
                e.preventDefault();
            });
            
            jumpButton.addEventListener('touchcancel', function(e) {
                gameState.keys.jump = false;
                
                // 移除按钮按下效果
                jumpButton.classList.remove('active');
                
                e.preventDefault();
            });

            // 响应式画布
            function resizeCanvas() {
                const container = document.getElementById('game-container');
                
                // 检查是否为横屏模式且是移动设备
                const isMobileAndLandscape = window.matchMedia("(max-width: 768px) and (orientation: landscape)").matches;
                
                if (isMobileAndLandscape) {
                    // 横屏模式下，保持比例最大化填充
                    const containerWidth = window.innerWidth;
                    const containerHeight = window.innerHeight;
                    const canvasRatio = canvas.width / canvas.height;
                    const containerRatio = containerWidth / containerHeight;
                    
                    let width, height;
                    
                    if (containerRatio > canvasRatio) {
                        // 容器更宽，以高度为基准
                        height = containerHeight;
                        width = height * canvasRatio;
                    } else {
                        // 容器更高，以宽度为基准
                        width = containerWidth;
                        height = width / canvasRatio;
                    }
                    
                    // 应用计算后的尺寸
                    canvas.style.width = width + 'px';
                    canvas.style.height = height + 'px';
                    
                    // 调整触控按钮位置以适应新布局
                    const touchControls = document.querySelector('.touch-controls');
                    if (touchControls) {
                        touchControls.style.bottom = '20px';
                        touchControls.style.width = width + 'px';
                        touchControls.style.left = '50%';
                        touchControls.style.transform = 'translateX(-50%)';
                    }
                } else {
                    // 正常模式
                    const maxWidth = Math.min(container.clientWidth, 1920);
                    const scale = maxWidth / canvas.width;
                    
                    canvas.style.width = maxWidth + 'px';
                    canvas.style.height = (canvas.height * scale) + 'px';
                    
                    // 重置触控按钮样式
                    const touchControls = document.querySelector('.touch-controls');
                    if (touchControls) {
                        touchControls.style.bottom = '10px';
                        touchControls.style.width = '100%';
                        touchControls.style.left = '0';
                        touchControls.style.transform = 'none';
                    }
                }
            }

            // 监听屏幕方向变化和尺寸变化
            window.addEventListener('resize', resizeCanvas);
            window.addEventListener('orientationchange', function() {
                // 方向改变后稍微延迟执行以确保新尺寸已经生效
                setTimeout(resizeCanvas, 100);
            });

            // 游戏状态
            const gameState = {
                gameStarted: false,
                player: {
                    x: 50,
                    y: 100, // 修改初始Y位置，与上面保持一致
                    width: 30,
                    height: 50,
                    velocityX: 0,
                    velocityY: 0,
                    speed: 2.5,
                    jumpForce: 7.5,
                    gravity: 0.2, // 确保重力参数存在
                    isJumping: false,
                    jumpCount: 0,
                    maxJumps: 2,
                    facingRight: true, // 确保添加此属性
                    color: '#ff5a5f', // 添加默认颜色
                    collected: 0,
                    sprite: null,
                    // 添加动画相关属性
                    frameWidth: 1280, 
                    frameHeight: 760,
                    currentFrame: 0,
                    currentRow: 0,
                    frameCount: 5,
                    animationSpeed: 0.15,
                    animationTimer: 0,
                    isRunning: false,
                    // 添加茶复活效果状态
                    teaEffect: {
                        active: false,
                        duration: 0,
                        maxDuration: 180, // 3秒 * 60帧
                        particles: []
                    },
                    // 添加踩踏平台记录
                    lastSteppedPlatforms: [],
                    // 添加初始气泡状态
                },
                keys: {
                    left: false,
                    right: false,
                    jump: false
                },
                platforms: [],
                bubbleSpawners: [
                    // 气泡生成点 - 延长覆盖整个关卡
                    { x: 0, width: 160, spawnY: canvas.height + 50, interval: 4000, lastSpawn: 0 },
                    { x: 100, width: 160, spawnY: canvas.height + 50, interval: 4200, lastSpawn: 1000 },
                    { x: 200, width: 100, spawnY: canvas.height + 50, interval: 4200, lastSpawn: 1500 },
                    { x: 255, width: 100, spawnY: canvas.height + 50, interval: 4400, lastSpawn: 2000 },
                    { x: 310, width: 80, spawnY: canvas.height + 50, interval: 4100, lastSpawn: 1000 },
                    { x: 360, width: 80, spawnY: canvas.height + 50, interval: 4400, lastSpawn: 2000 },
                    { x: 410, width: 80, spawnY: canvas.height + 50, interval: 4200, lastSpawn: 1500 },
                    { x: 480, width: 80, spawnY: canvas.height + 50, interval: 4100, lastSpawn: 3000 },
                    { x: 550, width: 80, spawnY: canvas.height + 50, interval: 4200, lastSpawn: 3000 },
                    { x: 600, width: 100, spawnY: canvas.height + 50, interval: 4300, lastSpawn: 500 },
                    { x: 750, width: 80, spawnY: canvas.height + 50, interval: 4500, lastSpawn: 1500 },
                    { x: 900, width: 100, spawnY: canvas.height + 50, interval: 4200, lastSpawn: 2500 },
                    { x: 1050, width: 80, spawnY: canvas.height + 50, interval: 4600, lastSpawn: 3500 },
                    { x: 1200, width: 120, spawnY: canvas.height + 50, interval: 4100, lastSpawn: 1200 },
                    { x: 1350, width: 60, spawnY: canvas.height + 50, interval: 4300, lastSpawn: 2200 },
                    { x: 1500, width: 80, spawnY: canvas.height + 50, interval: 4500, lastSpawn: 3300 },
                    { x: 1650, width: 100, spawnY: canvas.height + 50, interval: 4200, lastSpawn: 800 },
                    { x: 1800, width: 80, spawnY: canvas.height + 50, interval: 4400, lastSpawn: 1800 },
                    { x: 1950, width: 120, spawnY: canvas.height + 50, interval: 4300, lastSpawn: 2800 },
                    { x: 2100, width: 60, spawnY: canvas.height + 50, interval: 4500, lastSpawn: 3800 },
                    { x: 2250, width: 80, spawnY: canvas.height + 50, interval: 4100, lastSpawn: 900 },
                    { x: 2400, width: 100, spawnY: canvas.height + 50, interval: 4400, lastSpawn: 1900 },
                    { x: 2550, width: 80, spawnY: canvas.height + 50, interval: 4200, lastSpawn: 2900 },
                    { x: 2700, width: 120, spawnY: canvas.height + 50, interval: 4600, lastSpawn: 3900 },
                    { x: 2850, width: 60, spawnY: canvas.height + 50, interval: 4100, lastSpawn: 1000 },
                    { x: 3000, width: 100, spawnY: canvas.height + 50, interval: 4300, lastSpawn: 2000 },
                    { x: 3150, width: 80, spawnY: canvas.height + 50, interval: 4500, lastSpawn: 3000 },
                    { x: 3300, width: 120, spawnY: canvas.height + 50, interval: 4200, lastSpawn: 400 },
                    { x: 3450, width: 60, spawnY: canvas.height + 50, interval: 4400, lastSpawn: 1400 },
                    { x: 3600, width: 80, spawnY: canvas.height + 50, interval: 4100, lastSpawn: 2400 },
                    { x: 3750, width: 100, spawnY: canvas.height + 50, interval: 4300, lastSpawn: 3400 },
                    { x: 3900, width: 80, spawnY: canvas.height + 50, interval: 4500, lastSpawn: 500 },
                    { x: 4050, width: 120, spawnY: canvas.height + 50, interval: 4200, lastSpawn: 1500 },
                    { x: 4200, width: 60, spawnY: canvas.height + 50, interval: 4400, lastSpawn: 2500 },
                    { x: 4350, width: 80, spawnY: canvas.height + 50, interval: 4300, lastSpawn: 3500 },
                    { x: 4500, width: 100, spawnY: canvas.height + 50, interval: 4500, lastSpawn: 600 },
                    { x: 4650, width: 80, spawnY: canvas.height + 50, interval: 4200, lastSpawn: 1600 },
                    { x: 4800, width: 120, spawnY: canvas.height + 50, interval: 4400, lastSpawn: 2600 },
                    { x: 4950, width: 60, spawnY: canvas.height + 50, interval: 4100, lastSpawn: 3600 },
                    { x: 5100, width: 80, spawnY: canvas.height + 50, interval: 4300, lastSpawn: 700 },
                    { x: 5250, width: 100, spawnY: canvas.height + 50, interval: 4500, lastSpawn: 1700 },
                    { x: 5400, width: 80, spawnY: canvas.height + 50, interval: 4200, lastSpawn: 2700 },
                    { x: 5550, width: 120, spawnY: canvas.height + 50, interval: 4400, lastSpawn: 3700 },
                    { x: 5700, width: 60, spawnY: canvas.height + 50, interval: 4100, lastSpawn: 800 },
                    { x: 5850, width: 80, spawnY: canvas.height + 50, interval: 4300, lastSpawn: 1800 },
                    { x: 6000, width: 100, spawnY: canvas.height + 50, interval: 4500, lastSpawn: 2800 },
                    { x: 6150, width: 80, spawnY: canvas.height + 50, interval: 4200, lastSpawn: 3800 },
                    { x: 6300, width: 120, spawnY: canvas.height + 50, interval: 4400, lastSpawn: 900 },
                    // 新增的气泡生成点，覆盖延长部分
                    { x: 6450, width: 60, spawnY: canvas.height + 50, interval: 4300, lastSpawn: 1900 },
                    { x: 6600, width: 80, spawnY: canvas.height + 50, interval: 4500, lastSpawn: 2900 },
                    { x: 6750, width: 100, spawnY: canvas.height + 50, interval: 4200, lastSpawn: 3900 },
                    { x: 6900, width: 80, spawnY: canvas.height + 50, interval: 4400, lastSpawn: 1000 },
                    { x: 7050, width: 120, spawnY: canvas.height + 50, interval: 4100, lastSpawn: 2000 },
                    { x: 7200, width: 60, spawnY: canvas.height + 50, interval: 4300, lastSpawn: 3000 },
                    { x: 7350, width: 80, spawnY: canvas.height + 50, interval: 4500, lastSpawn: 1100 },
                    { x: 7500, width: 100, spawnY: canvas.height + 50, interval: 4200, lastSpawn: 2100 },
                    { x: 7650, width: 80, spawnY: canvas.height + 50, interval: 4400, lastSpawn: 3100 },
                    { x: 7800, width: 120, spawnY: canvas.height + 50, interval: 4100, lastSpawn: 1200 },
                    { x: 7950, width: 60, spawnY: canvas.height + 50, interval: 4300, lastSpawn: 2200 },
                    { x: 8100, width: 80, spawnY: canvas.height + 50, interval: 4500, lastSpawn: 3200 },
                    { x: 8250, width: 100, spawnY: canvas.height + 50, interval: 4200, lastSpawn: 1300 },
                    { x: 8400, width: 80, spawnY: canvas.height + 50, interval: 4400, lastSpawn: 2300 },
                    { x: 8550, width: 120, spawnY: canvas.height + 50, interval: 4100, lastSpawn: 3300 },
                    { x: 8700, width: 60, spawnY: canvas.height + 50, interval: 4300, lastSpawn: 1400 },
                    { x: 8850, width: 80, spawnY: canvas.height + 50, interval: 4500, lastSpawn: 2400 },
                    // 为延长的关卡添加更多气泡生成点
                    { x: 9000, width: 100, spawnY: canvas.height + 50, interval: 4200, lastSpawn: 3400 },
                    { x: 9150, width: 80, spawnY: canvas.height + 50, interval: 4400, lastSpawn: 1000 },
                    { x: 9300, width: 120, spawnY: canvas.height + 50, interval: 4100, lastSpawn: 2000 },
                    { x: 9450, width: 60, spawnY: canvas.height + 50, interval: 4300, lastSpawn: 3000 },
                    { x: 9600, width: 80, spawnY: canvas.height + 50, interval: 4500, lastSpawn: 1100 },
                    { x: 9750, width: 100, spawnY: canvas.height + 50, interval: 4200, lastSpawn: 2100 },
                    { x: 9900, width: 80, spawnY: canvas.height + 50, interval: 4400, lastSpawn: 3100 },
                    { x: 10050, width: 120, spawnY: canvas.height + 50, interval: 4100, lastSpawn: 1200 },
                    { x: 10200, width: 60, spawnY: canvas.height + 50, interval: 4300, lastSpawn: 2200 },
                    { x: 10350, width: 80, spawnY: canvas.height + 50, interval: 4500, lastSpawn: 3200 },
                    { x: 10500, width: 100, spawnY: canvas.height + 50, interval: 4200, lastSpawn: 1300 },
                    { x: 10650, width: 80, spawnY: canvas.height + 50, interval: 4400, lastSpawn: 2300 },
                    { x: 10800, width: 120, spawnY: canvas.height + 50, interval: 4100, lastSpawn: 3300 },
                    { x: 10950, width: 60, spawnY: canvas.height + 50, interval: 4300, lastSpawn: 1400 },
                    { x: 11100, width: 80, spawnY: canvas.height + 50, interval: 4500, lastSpawn: 2400 },
                    { x: 11250, width: 100, spawnY: canvas.height + 50, interval: 4200, lastSpawn: 3400 },
                    { x: 11400, width: 80, spawnY: canvas.height + 50, interval: 4400, lastSpawn: 1500 },
                    { x: 11550, width: 120, spawnY: canvas.height + 50, interval: 4100, lastSpawn: 2500 },
                    { x: 11700, width: 60, spawnY: canvas.height + 50, interval: 4300, lastSpawn: 3500 },
                    { x: 11850, width: 80, spawnY: canvas.height + 50, interval: 4500, lastSpawn: 1600 },
                                        // 继续添加气泡生成点，覆盖12000-15000的范围
                    { x: 12000, width: 100, spawnY: canvas.height + 50, interval: 4200, lastSpawn: 1700 },
                    { x: 12150, width: 80, spawnY: canvas.height + 50, interval: 4400, lastSpawn: 2700 },
                    { x: 12300, width: 120, spawnY: canvas.height + 50, interval: 4100, lastSpawn: 3700 },
                    { x: 12450, width: 60, spawnY: canvas.height + 50, interval: 4300, lastSpawn: 1800 },
                    { x: 12600, width: 80, spawnY: canvas.height + 50, interval: 4500, lastSpawn: 2800 },
                    { x: 12750, width: 100, spawnY: canvas.height + 50, interval: 4200, lastSpawn: 3800 },
                    { x: 12900, width: 80, spawnY: canvas.height + 50, interval: 4400, lastSpawn: 1900 },
                    { x: 13050, width: 120, spawnY: canvas.height + 50, interval: 4100, lastSpawn: 2900 },
                    { x: 13200, width: 60, spawnY: canvas.height + 50, interval: 4300, lastSpawn: 3900 },
                    { x: 13350, width: 80, spawnY: canvas.height + 50, interval: 4500, lastSpawn: 2000 },
                    { x: 13500, width: 100, spawnY: canvas.height + 50, interval: 4200, lastSpawn: 3000 },
                    { x: 13650, width: 80, spawnY: canvas.height + 50, interval: 4400, lastSpawn: 4000 },
                    { x: 13800, width: 120, spawnY: canvas.height + 50, interval: 4100, lastSpawn: 2100 },
                    { x: 13950, width: 60, spawnY: canvas.height + 50, interval: 4300, lastSpawn: 3100 },
                    { x: 14100, width: 80, spawnY: canvas.height + 50, interval: 4500, lastSpawn: 4100 },
                    { x: 14250, width: 100, spawnY: canvas.height + 50, interval: 4200, lastSpawn: 2200 },
                    { x: 14400, width: 80, spawnY: canvas.height + 50, interval: 4400, lastSpawn: 3200 },
                    { x: 14550, width: 120, spawnY: canvas.height + 50, interval: 4100, lastSpawn: 4200 },
                    { x: 14700, width: 60, spawnY: canvas.height + 50, interval: 4300, lastSpawn: 2300 },
                    { x: 14850, width: 80, spawnY: canvas.height + 50, interval: 4500, lastSpawn: 3300 },
                    { x: 15000, width: 80, spawnY: canvas.height + 50, interval: 4200, lastSpawn: 3000 },
                    // 在现有气泡生成点后继续添加，覆盖15000-16000米的范围
                    { x: 15000, width: 100, spawnY: canvas.height + 50, interval: 4200, lastSpawn: 3400 },
                    { x: 15150, width: 80, spawnY: canvas.height + 50, interval: 4400, lastSpawn: 4400 },
                    { x: 15300, width: 120, spawnY: canvas.height + 50, interval: 4100, lastSpawn: 2400 },
                    { x: 15450, width: 60, spawnY: canvas.height + 50, interval: 4300, lastSpawn: 3400 },
                    { x: 15600, width: 80, spawnY: canvas.height + 50, interval: 4500, lastSpawn: 4400 },
                    { x: 15750, width: 100, spawnY: canvas.height + 50, interval: 4200, lastSpawn: 2400 },
                    { x: 15900, width: 80, spawnY: canvas.height + 50, interval: 4400, lastSpawn: 3400 },
                                        // 在现有气泡生成点后继续添加，覆盖16000-17000米的范围
                    { x: 16000, width: 100, spawnY: canvas.height + 50, interval: 4200, lastSpawn: 4400 },
                    { x: 16150, width: 80, spawnY: canvas.height + 50, interval: 4400, lastSpawn: 2400 },
                    { x: 16300, width: 120, spawnY: canvas.height + 50, interval: 4100, lastSpawn: 3400 },
                    { x: 16450, width: 60, spawnY: canvas.height + 50, interval: 4300, lastSpawn: 4400 },
                    { x: 16600, width: 80, spawnY: canvas.height + 50, interval: 4500, lastSpawn: 2400 },
                    { x: 16750, width: 100, spawnY: canvas.height + 50, interval: 4200, lastSpawn: 3400 },
                    { x: 16900, width: 80, spawnY: canvas.height + 50, interval: 4400, lastSpawn: 4400 }
                ],
                    // 终点平台
                endPlatform: { 
                    x: 17000, 
                    y: 140, 
                    width: 180,  // 与固定平台相同的宽度
                    height: 20,  // 与固定平台相同的高度
                    color: '#5a7a95', // 与固定平台相同的颜色
                    isSeaStyle: true // 使用海底风格
                },
                flag: { x: 17050, y: 110, width: 20, height: 30, color: '#77dd77' },
                // 添加宝箱相关属性
                chest: {
                    x: 17030, 
                    y: 100,           // 上移宝箱位置以适应更大的尺寸
                    width: 140,      // 宽度增加到两倍
                    height: 140,     // 高度增加到两倍
                    sprite: null,
                    frameWidth: 50,  // 每一帧的宽度为50像素
                    frameHeight: 50, // 每一帧的高度为50像素
                    totalFrames: 7,  // 总共7帧动画
                    currentFrame: 0,
                    animationSpeed: 0.15,
                    animationTimer: 0,
                    isAnimating: false,
                    isOpened: false,
                    color: '#77dd77',  // 保留颜色属性，用于备用显示
                    useDrawnChest: false // 是否使用绘制的宝箱，而不是精灵图
                },
                // 添加固定平台
                staticPlatforms: [
                    // 关卡开始位置附近
                    { x: 600, y: 250, width: 150, height: 20, color: '#5a7a95' },
                    // 关卡前部位置
                    { x: 1800, y: 280, width: 180, height: 20, color: '#5a7a95' },
                    // 关卡前中部位置
                    { x: 3200, y: 280, width: 200, height: 20, color: '#5a7a95' },
                    // 关卡中间位置
                    { x: 4800, y: 220, width: 180, height: 20, color: '#5a7a95' },
                    // 关卡中间偏后位置
                    { x: 6500, y: 260, width: 200, height: 20, color: '#5a7a95' },
                    // 关卡后段中部
                    { x: 8000, y: 220, width: 180, height: 20, color: '#5a7a95' },
                    // 新增平台以覆盖延长的关卡
                    // 关卡后段
                    { x: 9900, y: 250, width: 200, height: 20, color: '#5a7a95' },
                    // 关卡末端前
                    { x: 13000, y: 230, width: 170, height: 20, color: '#5a7a95' },
                    { x: 15500, y: 230, width: 170, height: 20, color: '#5a7a95' }
                ],
                gameOver: false,
                victory: false,
                victoryPending: false, // 是否正在等待胜利
                victoryDelay: 0, // 胜利延迟帧数
                camera: {
                    x: 0,
                    y: 0
                },
                particles: [],
                // 添加海底场景元素
                pirateElements: [],
                // 添加帧计数器
                frameCount: 0,
                // 初始化空的星星数组
                stars: [],
                // 初始化茶收集物数组
                teas: [],
                // 茶收集数量
                collectedTeas: 0,
                // 茶刷新计时器
                teaSpawnTimer: 0,
                // 茶刷新间隔(毫秒)
                teaSpawnInterval: 8000,
                restartListenerAdded: false,
                restartButton: null,
                startBubble: null, // 添加初始气泡对象
                // 添加海底尖刺配置，便于调整
                spikes: {
                    // 尖刺位置和大小参数
                    count: 180, // 尖刺数量
                    baseHeight: 45, // 基础高度
                    heightVariation: 15, // 高度变化范围
                    width: 9, // 尖刺宽度
                    widthVariation: 3, // 宽度变化范围
                    yPosition: 600, // 尖刺底部Y坐标（靠近画布底部）
                    // 尖刺外观参数
                    baseColor: '#0b3a54', // 基础颜色
                    tipColor: '#1a6281', // 尖刺尖端颜色
                    glowColor: 'rgba(100, 200, 255, 0.1)', // 发光效果颜色
                    // 尖刺装饰参数
                    hasBubbles: true, // 是否添加气泡装饰
                    hasAlgae: true, // 是否添加藻类装饰
                    bubbleDensity: 0.1, // 气泡密度
                    algaeDensity: 0.1, // 藻类密度
                    // 动画参数
                    animationSpeed: 0.01, // 微动画速度
                    animationAmount: 0.25 // 微动画幅度
                },
                goldRain: {
                    active: false,
                    duration: 0,
                    nextSpawn: 0,
                    spawnInterval: 0
                },
                gmPanel: null,  // GM指令面板
                gmMessage: null, // GM消息
                godMode: false   // 无敌模式
            };

            // 加载图片资源
            const playerSprite = new Image();
            playerSprite.src = 'sprite02.png';
            playerSprite.onload = function() {
                // 更正属性名，确保与drawPlayer函数中使用的一致
                gameState.player.sprite = playerSprite;
                console.log("玩家精灵图已加载");
            };

            // 修改加载宝箱精灵图的代码，确保图像完整加载
            let chestSprite = new Image();
            // 移除 crossOrigin 属性，这可能导致本地文件加载失败
            chestSprite.onload = function() {
                console.log("宝箱精灵图已加载", chestSprite.width, chestSprite.height);
                
                // 如果精灵图宽度不是350 (7帧 * 50px)，可能需要调整每帧宽度
                if (chestSprite.width != 350) {
                    const frameCount = 7; // 总共7帧
                    gameState.chest.frameWidth = chestSprite.width / frameCount;
                    console.log("调整每帧宽度为:", gameState.chest.frameWidth);
                }
                
                gameState.chest.sprite = chestSprite;
                
                // 调整宝箱位置以适应终点平台
                gameState.chest.x = gameState.endPlatform.x + (gameState.endPlatform.width / 2) - (gameState.chest.width / 2);
                gameState.chest.y = gameState.endPlatform.y - gameState.chest.height - 5;
            };
            chestSprite.onerror = function(e) {
                console.error("宝箱精灵图加载失败", e);
                // 不再尝试加载备用图片，直接使用绘制的宝箱
                console.log("将使用绘制的宝箱替代精灵图");
                
                // 设置标志，表示我们将使用绘制的宝箱
                gameState.chest.useDrawnChest = true;
            };
            chestSprite.src = 'jinbibaoxiang.png'; // 在设置事件之后设置src

            // 键盘控制
            window.addEventListener('keydown', function(e) {
                if (e.key === 'a' || e.key === 'ArrowLeft') {
                    gameState.keys.left = true;
                } else if (e.key === 'd' || e.key === 'ArrowRight') {
                    gameState.keys.right = true;
                } else if (e.key === 'w' || e.key === 'ArrowUp') {
                    gameState.keys.jump = true;
                }
                
                // GM指令系统 - 仅开发测试使用
                // 按下G键激活GM面板
                if (e.key === 'g' && !gameState.gmPanel) {
                    console.log("GM面板已激活");
                    gameState.gmPanel = {
                        active: true,
                        commands: [
                            { key: '1', desc: '收集全部金牌', action: collectAllMedals },
                            { key: '2', desc: '传送到终点', action: teleportToEnd },
                            { key: '3', desc: '开启无敌模式', action: toggleGodMode },
                            { key: '4', desc: '重置游戏', action: resetGame }
                        ]
                    };
                    
                    // 显示可用指令
                    console.log("可用GM指令:");
                    gameState.gmPanel.commands.forEach(cmd => {
                        console.log(`${cmd.key}: ${cmd.desc}`);
                    });
                }
                
                // 处理GM命令
                if (gameState.gmPanel && gameState.gmPanel.active) {
                    // 查找匹配的命令
                    const command = gameState.gmPanel.commands.find(cmd => cmd.key === e.key);
                    if (command) {
                        console.log(`执行GM命令: ${command.desc}`);
                        command.action();
                    }
                }
            });

            window.addEventListener('keyup', function(e) {
                if (e.key === 'a' || e.key === 'ArrowLeft') {
                    gameState.keys.left = false;
                } else if (e.key === 'd' || e.key === 'ArrowRight') {
                    gameState.keys.right = false;
                } else if (e.key === 'w' || e.key === 'ArrowUp') {
                    gameState.keys.jump = false;
                }
            });

            // 触摸控制
            leftBtn.addEventListener('touchstart', () => gameState.keys.left = true);
            leftBtn.addEventListener('touchend', () => gameState.keys.left = false);
            rightBtn.addEventListener('touchstart', () => gameState.keys.right = true);
            rightBtn.addEventListener('touchend', () => gameState.keys.right = false);
            jumpBtn.addEventListener('touchstart', () => gameState.keys.jump = true);
            jumpBtn.addEventListener('touchend', () => gameState.keys.jump = false);

            // 鼠标控制（用于桌面触摸）
            leftBtn.addEventListener('mousedown', () => gameState.keys.left = true);
            leftBtn.addEventListener('mouseup', () => gameState.keys.left = false);
            leftBtn.addEventListener('mouseleave', () => gameState.keys.left = false);
            rightBtn.addEventListener('mousedown', () => gameState.keys.right = true);
            rightBtn.addEventListener('mouseup', () => gameState.keys.right = false);
            rightBtn.addEventListener('mouseleave', () => gameState.keys.right = false);
            jumpBtn.addEventListener('mousedown', () => gameState.keys.jump = true);
            jumpBtn.addEventListener('mouseup', () => gameState.keys.jump = false);
            jumpBtn.addEventListener('mouseleave', () => gameState.keys.jump = false);

            // 绘制开始屏幕
            function drawStartScreen() {
                // 绘制半透明背景覆盖层
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // 绘制游戏标题
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 40px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('茶茶乐淘金记Ⅱ：深海', canvas.width / 2, canvas.height / 2 - 50);
                
                // 添加作者署名
                ctx.font = 'bold 18px Arial';
                ctx.fillStyle = '#dddddd';
                ctx.fillText('BY：刺', canvas.width / 2, canvas.height / 2 - 15);
                
                // 绘制开始按钮
                const btnWidth = 180;
                const btnHeight = 50;
                const btnX = canvas.width / 2 - btnWidth / 2;
                const btnY = canvas.height / 2 + 40;
                
                // 按钮背景
                ctx.fillStyle = '#4a90e2';
                ctx.fillRect(btnX, btnY, btnWidth, btnHeight);
                
                // 按钮文字
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 20px Arial';
                ctx.fillText('开始游戏', canvas.width / 2, btnY + btnHeight / 2 + 7);
                
                // 添加简短游戏说明
                ctx.font = '16px Arial';
                ctx.fillStyle = '#dddddd';
                ctx.fillText('特邀顾问：不嗑真的', canvas.width / 2, canvas.height / 2 + 10);
                
                // 保存按钮信息，用于点击检测
                const startButton = {
                    x: btnX,
                    y: btnY,
                    width: btnWidth,
                    height: btnHeight
                };
                
                // 添加按钮点击事件
                canvas.onclick = function(e) {
                    const rect = canvas.getBoundingClientRect();
                    const scaleX = canvas.width / rect.width;
                    const scaleY = canvas.height / rect.height;
                    const clickX = (e.clientX - rect.left) * scaleX;
                    const clickY = (e.clientY - rect.top) * scaleY;
                    
                    if (clickX >= startButton.x && clickX <= startButton.x + startButton.width &&
                        clickY >= startButton.y && clickY <= startButton.y + startButton.height) {
                        // 显示加载中提示
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                        ctx.fillStyle = '#ffffff';
                        ctx.font = 'bold 24px Arial';
                        ctx.fillText('加载中...', canvas.width / 2, canvas.height / 2);
                        
                        // 使用setTimeout延迟初始化，让界面有时间刷新
                        setTimeout(function() {
                            try {
                                // 初始化游戏元素
                                initializeGameElements();
                                gameState.gameStarted = true;
                                canvas.onclick = null; // 移除点击事件
                            } catch (error) {
                                console.error("游戏启动时出错:", error);
                                // 即使出错也设置游戏为已开始状态
                                gameState.gameStarted = true;
                                canvas.onclick = null;
                            }
                        }, 100);
                    }
                };
                
                // 触摸支持
                canvas.ontouchstart = function(e) {
                    e.preventDefault();
                    const rect = canvas.getBoundingClientRect();
                    const scaleX = canvas.width / rect.width;
                    const scaleY = canvas.height / rect.height;
                    const touchX = (e.touches[0].clientX - rect.left) * scaleX;
                    const touchY = (e.touches[0].clientY - rect.top) * scaleY;
                    
                    if (touchX >= startButton.x && touchX <= startButton.x + startButton.width &&
                        touchY >= startButton.y && touchY <= startButton.y + startButton.height) {
                        // 显示加载中提示
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                        ctx.fillStyle = '#ffffff';
                        ctx.font = 'bold 24px Arial';
                        ctx.fillText('加载中...', canvas.width / 2, canvas.height / 2);
                        
                        // 使用setTimeout延迟初始化，让界面有时间刷新
                        setTimeout(function() {
                            try {
                                // 初始化游戏元素
                                initializeGameElements();
                                gameState.gameStarted = true;
                                canvas.ontouchstart = null; // 移除触摸事件
                            } catch (error) {
                                console.error("游戏启动时出错:", error);
                                // 即使出错也设置游戏为已开始状态
                                gameState.gameStarted = true;
                                canvas.ontouchstart = null;
                            }
                        }, 100);
                    }
                };
            }

            // 初始化游戏元素函数 - 将游戏元素初始化从游戏开始时分离出来
            function initializeGameElements() {
                try {
                    // 记录游戏开始时间，用于第一波气泡速度调整
                    gameState.gameStartTime = Date.now();
                    
                    // 初始化音频系统
                    initAudioSystem();
                    
                    // 创建海底场景元素
                    createPirateScene();
                    
                    // 创建星星收集物
                    createMedals();
                    
                    // 创建茶收集物
                    createTeas();
                    
                    // 创建尖刺数组
                    createSpikes();
                    
                    // 确保玩家站在初始气泡上
                    createInitialBubble();
                    
                    console.log("游戏元素已初始化");
                } catch (error) {
                    console.error("初始化游戏元素时出错:", error);
                    // 即使出错也设置游戏为已开始状态，避免卡在加载界面
                    gameState.gameStarted = true;
                }
            }

            // 初始化音频系统函数
            function initAudioSystem() {
                // 创建音频系统对象
                const audioSystem = {
                    context: null,
                    gainNode: null,
                    bufferCache: {},
                    soundPool: {},
                    unlocked: false,
                    
                    // 初始化方法
                    init: function() {
                        try {
                            console.log("初始化音频系统");
                            
                            // 尝试创建WebAudio上下文
                            const AudioContext = window.AudioContext || window.webkitAudioContext;
                            if (AudioContext) {
                                this.context = new AudioContext();
                                this.gainNode = this.context.createGain();
                                this.gainNode.gain.value = 0.5; // 设置音量为50%
                                this.gainNode.connect(this.context.destination);
                                
                                console.log("WebAudio上下文已创建");
                            } else {
                                console.warn("浏览器不支持Web Audio API");
                            }
                            
                            // 设置音频解锁事件
                            this.setupUnlock();
                            
                            // 预加载音频文件
                            this.preloadSounds();
                            
                            // 设置音频上下文状态监控
                            this.monitorContext();
                        } catch (error) {
                            console.error("初始化音频系统出错:", error);
                        }
                    },
                    
                    // 设置音频解锁机制（针对移动浏览器）
                    setupUnlock: function() {
                        if (!this.context) return;
                        
                        const resumeAudio = () => {
                            if (this.unlocked) return;
                            
                            if (this.context.state === 'suspended') {
                                this.context.resume().then(() => {
                                    console.log("音频上下文已恢复");
                                }).catch(err => {
                                    console.error("恢复音频上下文失败:", err);
                                });
                            }
                            
                            // 创建并播放一个静音缓冲区以解锁音频
                            const buffer = this.context.createBuffer(1, 1, 22050);
                            const source = this.context.createBufferSource();
                            source.buffer = buffer;
                            source.connect(this.context.destination);
                            source.start(0);
                            
                            // 标记为已解锁
                            this.unlocked = true;
                            console.log("音频系统已解锁");
                            
                            // 移除事件监听器
                            document.removeEventListener('touchstart', resumeAudio);
                            document.removeEventListener('touchend', resumeAudio);
                            document.removeEventListener('click', resumeAudio);
                        };
                        
                        // 添加触摸和点击事件以解锁音频
                        document.addEventListener('touchstart', resumeAudio, false);
                        document.addEventListener('touchend', resumeAudio, false);
                        document.addEventListener('click', resumeAudio, false);
                    },
                    
                    // 监控音频上下文状态
                    monitorContext: function() {
                        if (!this.context) return;
                        
                        setInterval(() => {
                            if (this.context.state === 'suspended') {
                                console.log("检测到音频上下文已暂停，尝试恢复...");
                                this.context.resume().then(() => {
                                    console.log("音频上下文已恢复");
                                }).catch(err => {
                                    console.error("恢复音频上下文失败:", err);
                                });
                            }
                        }, 3000); // 每3秒检查一次
                    },
                    
                    // 预加载所有游戏音效
                    preloadSounds: function() {
                        // 定义要加载的声音
                        const sounds = [
                            "chayinxiao.mp3",     // 茶音效
                            "shengliyinxiao.mp3", // 胜利音效
                            "shibaiyinxiao.mp3",  // 失败音效
                            "shoujijinbi.mp3",    // 收集金币音效
                            "qipaoposui.mp3",     // 气泡破碎音效
                            "quanshoujiyinxiao.mp3" // 全收集音效
                        ];
                        
                        sounds.forEach(soundFile => {
                            this.loadSound(soundFile);
                        });
                    },
                    
                    // 加载单个音效
                    loadSound: function(url) {
                        if (!this.context) return;
                        
                        // 避免重复加载
                        if (this.bufferCache[url]) return;
                        
                        console.log(`加载音效: ${url}`);
                        
                        // 创建XHR请求加载音频文件
                        const request = new XMLHttpRequest();
                        request.open('GET', url, true);
                        request.responseType = 'arraybuffer';
                        
                        request.onload = () => {
                            // 解码音频数据
                            this.context.decodeAudioData(
                                request.response,
                                (buffer) => {
                                    this.bufferCache[url] = buffer;
                                    console.log(`音效加载完成: ${url}`);
                                },
                                (error) => {
                                    console.error(`解码音频失败: ${url}`, error);
                                }
                            );
                        };
                        
                        request.onerror = () => {
                            console.error(`加载音频文件失败: ${url}`);
                        };
                        
                        try {
                            request.send();
                        } catch (error) {
                            console.error(`发送音频请求失败: ${url}`, error);
                        }
                    },
                    
                    // 播放音效
                    playSound: function(name, options = {}) {
                        // 确保音频已解锁
                        if (this.context && this.context.state === 'suspended') {
                            this.context.resume();
                        }
                        
                        const url = name.indexOf('.mp3') !== -1 ? name : name + '.mp3';
                        const buffer = this.bufferCache[url];
                        
                        if (!buffer && this.context) {
                            console.log(`音效 ${url} 未加载，尝试动态加载`);
                            this.loadSound(url);
                            return;
                        }
                        
                        try {
                            if (this.context && buffer) {
                                // 创建音频源
                                const source = this.context.createBufferSource();
                                source.buffer = buffer;
                                
                                // 创建增益节点控制音量
                                const gainNode = this.context.createGain();
                                gainNode.gain.value = options.volume !== undefined ? options.volume : 0.5;
                                
                                // 连接节点
                                source.connect(gainNode);
                                gainNode.connect(this.gainNode);
                                
                                // 开始播放
                                source.start(0);
                                
                                // 管理音频池
                                const id = Date.now().toString();
                                this.soundPool[id] = {
                                    source: source,
                                    gainNode: gainNode
                                };
                                
                                // 设置播放完成回调
                                source.onended = () => {
                                    delete this.soundPool[id];
                                };
                                
                                return id;
                            } else {
                                // 备用方案：使用Audio元素
                                const audio = new Audio(url);
                                audio.volume = options.volume !== undefined ? options.volume : 0.5;
                                audio.play().catch(error => {
                                    console.warn(`使用Audio播放失败: ${url}`, error);
                                });
                            }
                        } catch (error) {
                            console.error(`播放音效失败: ${url}`, error);
                            
                            // 最后的备用方案
                            try {
                                const audio = new Audio(url);
                                audio.volume = options.volume !== undefined ? options.volume : 0.5;
                                audio.play().catch(e => {
                                    console.warn(`备用播放方案也失败: ${url}`, e);
                                });
                            } catch (e) {
                                console.error(`所有播放方法都失败: ${url}`);
                            }
                        }
                    },
                    
                    // 停止特定音效
                    stopSound: function(id) {
                        if (this.soundPool[id]) {
                            try {
                                this.soundPool[id].source.stop();
                            } catch (error) {
                                console.warn(`停止音效失败: ${id}`, error);
                            }
                            delete this.soundPool[id];
                        }
                    },
                    
                    // 停止所有音效
                    stopAllSounds: function() {
                        for (const id in this.soundPool) {
                            this.stopSound(id);
                        }
                    },
                    
                    // 设置全局音量
                    setVolume: function(volume) {
                        if (this.gainNode) {
                            this.gainNode.gain.value = volume;
                        }
                    }
                };
                
                // 初始化音频系统
                audioSystem.init();
                
                // 保存到游戏状态中
                gameState.audioSystem = audioSystem;
                
                console.log("音频系统已初始化");
            }
            
            // 检查茶碰撞
            function checkTeaCollision() {
                for (let i = 0; i < gameState.teas.length; i++) {
                    const tea = gameState.teas[i];
                    if (!tea.collected &&
                        gameState.player.x + gameState.player.width > tea.x &&
                        gameState.player.x < tea.x + tea.width &&
                        gameState.player.y + gameState.player.height > tea.y &&
                        gameState.player.y < tea.y + tea.height) {
                        
                        tea.collected = true;
                        gameState.collectedTeas++;
                        
                        // 播放茶收集音效
                        if (gameState.audioSystem) {
                            gameState.audioSystem.playSound("chayinxiao");
                        }
                        
                        // 创建茶收集粒子效果
                        createTeaParticles(tea.x + tea.width / 2, tea.y + tea.height / 2);
                        
                        // 激活茶的效果
                        activateTeaEffect();
                    }
                }
            }
            
            // 检查金牌碰撞
            function checkStarCollision() {
                for (let i = 0; i < gameState.stars.length; i++) {
                    const star = gameState.stars[i];
                    if (!star.collected &&
                        gameState.player.x + gameState.player.width > star.x &&
                        gameState.player.x < star.x + star.width &&
                        gameState.player.y + gameState.player.height > star.y &&
                        gameState.player.y < star.y + star.height) {
                        
                        // 收集金牌
                        star.collected = true;
                        gameState.player.collected += 1;
                        
                        // 播放收集金牌的音效
                        if (gameState.audioSystem) {
                            gameState.audioSystem.playSound("shoujijinbi");
                        }
                        
                        // 创建金牌收集粒子效果
                        createMedalParticles(star.x + star.width / 2, star.y + star.height / 2);
                        
                        // 检查是否收集了所有星星，已完成胜利
                        checkAllStarsCollected();
                    }
                }
            }
            
            // 检查气泡碰撞
            function checkBubbleCollision() {
                // 检查玩家是否踩到气泡
                for (let i = 0; i < gameState.platforms.length; i++) {
                    const platform = gameState.platforms[i];
                    
                    // 玩家底部与平台顶部接触
                    if (gameState.player.y + gameState.player.height <= platform.y + 5 &&
                        gameState.player.y + gameState.player.height + gameState.player.velocityY >= platform.y - 5 &&
                        gameState.player.x + gameState.player.width > platform.x &&
                        gameState.player.x < platform.x + platform.width) {
                        
                        // 防止玩家重复踩同一个气泡
                        if (gameState.player.lastSteppedPlatforms.includes(i)) {
                            continue;
                        }
                        
                        // 只在玩家下落时处理踩踏
                        if (gameState.player.velocityY >= 0) {
                            gameState.player.y = platform.y - gameState.player.height;
                            gameState.player.velocityY = -3.5; // 弱化弹跳效果
                            gameState.player.isJumping = false;
                            gameState.player.jumpCount = 0; // 重置跳跃次数
                            
                            // 记录玩家踩过的平台
                            gameState.player.lastSteppedPlatforms.push(i);
                            
                            // 如果平台数组过长，移除最早的记录
                            if (gameState.player.lastSteppedPlatforms.length > 5) {
                                gameState.player.lastSteppedPlatforms.shift();
                            }
                            
                            // 播放气泡破裂音效
                            if (gameState.audioSystem) {
                                gameState.audioSystem.playSound("qipaoposui");
                            }
                            
                            // 设置气泡为破裂状态
                            platform.isPopping = true;
                            
                            // 创建气泡破裂粒子效果
                            createBubblePopParticles(platform.x + platform.width / 2, platform.y);
                        }
                    }
                }
            }
            
            // 更新胜利状态
            function updateVictoryState(elapsed) {
                // 如果胜利过程已经启动
                if (gameState.victoryPending && !gameState.victory) {
                    // 更新胜利延迟计时器
                    gameState.victoryDelay -= 60 * elapsed;
                    
                    // 当计时器归零，显示胜利画面
                    if (gameState.victoryDelay <= 0) {
                        gameState.victory = true;
                        gameState.gameOver = false;
                        
                        // 播放胜利音效
                        if (gameState.audioSystem) {
                            gameState.audioSystem.playSound("shengliyinxiao");
                            
                            // 如果收集了所有金牌，播放全收集音效
                            if (gameState.isFullCollection) {
                                setTimeout(() => {
                                    gameState.audioSystem.playSound("quanshoujiyinxiao");
                                }, 1000);
                            }
                        }
                    }
                }
            }
            
            // 处理游戏结束
            function handleGameOver() {
                // 如果已经处于游戏结束状态，不重复处理
                if (gameState.gameOver || gameState.victory) return;
                
                // 设置游戏结束状态
                gameState.gameOver = true;
                gameState.victory = false;
                
                // 播放失败音效
                if (gameState.audioSystem) {
                    gameState.audioSystem.playSound("shibaiyinxiao");
                }
                
                // 创建失败粒子效果
                createGameOverParticles(gameState.player.x + gameState.player.width / 2, gameState.player.y + gameState.player.height / 2);
                
                // 添加点击事件监听，用于重新开始游戏
                if (!gameState.restartListenerAdded) {
                    canvas.addEventListener('click', restartGame);
                    canvas.addEventListener('touchstart', restartGame);
                    gameState.restartListenerAdded = true;
                }
            }

            // 创建尖刺数组
            function createSpikes() {
                // 初始化尖刺数组
                gameState.spikesArray = [];
                
                // 获取尖刺配置
                const spikesConfig = gameState.spikes;
                
                // 计算尖刺间距
                const totalWidth = canvas.width * 3.5;
                const spikeSpacing = totalWidth / spikesConfig.count;
                
                // 创建尖刺对象
                for (let i = 0; i < spikesConfig.count; i++) {
                    // 计算尖刺位置
                    const baseX = i * spikeSpacing;
                    const height = spikesConfig.baseHeight + (Math.sin(i * 0.7) * spikesConfig.heightVariation);
                    const width = spikesConfig.width + (Math.cos(i * 0.5) * spikesConfig.widthVariation);
                    
                    // 添加到尖刺数组
                    gameState.spikesArray.push({
                        x: baseX,
                        y: spikesConfig.yPosition - height,
                        width: width,
                        height: height,
                        color: spikesConfig.baseColor
                    });
                }
                
                console.log(`创建了 ${gameState.spikesArray.length} 个尖刺`);
            }
            
            // 创建初始气泡函数
            function createInitialBubble() {
                // 确保玩家处于初始气泡状态
                gameState.player.onStartBubble = true;
                
                // 创建初始气泡，将Y坐标升高到120位置
                gameState.startBubble = {
                    x: gameState.player.x - 10,
                    y: 120, // 升高气泡的初始位置
                    width: 80,
                    height: 80,
                    scale: 1,
                    opacity: 0.8,
                    isSinking: false, // 初始不下沉，保持悬浮
                    sinkSpeed: 0.1,   // 减慢下沉速度
                    isPopping: false,
                    wobble: {
                        amount: 0.8,
                        speed: 0.03
                    }
                };
                
                // 调整玩家位置，确保站在气泡上
                gameState.player.x = gameState.startBubble.x + 10;
                gameState.player.y = gameState.startBubble.y - gameState.player.height + 5;
                gameState.player.velocityY = 0;
                gameState.player.isJumping = false;
                
                console.log("初始气泡已创建，玩家已放置在气泡上");
            }

            // 粒子效果
            function createJumpParticles(x, y) {
                for (let i = 0; i < 5; i++) {
                    gameState.particles.push({
                        x: x + gameState.player.width / 2,
                        y: y + gameState.player.height,
                        radius: Math.random() * 3 + 1,
                        color: '#ffffff',
                        velocityX: (Math.random() - 0.5) * 3,
                        velocityY: Math.random() * 2,
                        life: 20
                    });
                }
            }

            // 添加调色板
            const palette = {
                gold: '#ffd700',
                goldShine: '#ffb700',
                goldRibbon: '#ff6347',
                teaColor: '#5a3a28',
                teaSteam: 'rgba(200, 240, 255, 0.6)'
            };

            function createMedals() {
                // 清空现有收集物
                gameState.stars = [];
                gameState.stars.length = 0; // 确保完全清空
                
                // 保持金牌总数为84，但进一步增加关卡长度
                const medalCount = 84; // 总金牌数量保持84
                const levelLength = 17000; // 将关卡长度从9000增加到12000
                const paddingLeft = 200; // 增加左侧边距
                const paddingRight = 300; // 增加右侧边距
                
                // 可用于生成金牌的区域范围
                const availableArea = levelLength - paddingLeft - paddingRight;
                
                // 平均每个金牌的间距，确保均匀分布
                const avgDistance = availableArea / medalCount;
                
                // 设置最小间距，确保金牌不会太靠近
                const minDistanceBetweenMedals = avgDistance * 0.7;
                
                // 设置金牌之间的最小距离
                const minMedalSpacing = {
                    horizontal: 40, // 水平最小间距
                    vertical: 15    // 垂直最小间距，用于更严格的纵向检查
                };
                
                // 预先获取所有平台信息，包括静态平台和终点平台
                const allPlatforms = [...gameState.staticPlatforms];
                if (gameState.endPlatform) {
                    allPlatforms.push(gameState.endPlatform);
                }
                
                // 定义平台安全距离 - 金牌不应该放在这个距离范围内
                const platformHorizontalSafeDistance = 3; // 平台左右安全距离
                const platformAboveSafeDistance = 8; // 平台上方安全距离
                const platformBelowSafeDistance = 25; // 平台下方安全距离
                const medalSize = 25; // 金牌尺寸
                
                // 收集所有生成禁区
                const forbiddenZones = [];
                
                // 为每个平台添加禁区
                for (const platform of allPlatforms) {
                    forbiddenZones.push({
                        x: platform.x - platformHorizontalSafeDistance - medalSize,
                        y: platform.y - platformAboveSafeDistance - medalSize,
                        width: platform.width + 2 * platformHorizontalSafeDistance + 2 * medalSize,
                        height: platform.height + platformBelowSafeDistance + 2 * medalSize
                    });
                }
                
                // 为终点平台添加特殊的垂直禁区（从平台到画面底部）
                if (gameState.endPlatform) {
                    forbiddenZones.push({
                        x: gameState.endPlatform.x - platformHorizontalSafeDistance - medalSize,
                        y: 0, // 从顶部开始
                        width: gameState.endPlatform.width + 2 * platformHorizontalSafeDistance + 2 * medalSize,
                        height: canvas.height * 10 // 确保足够高以覆盖整个画面和更多
                    });
                }
                
                // 已生成的金牌位置列表
                const generatedMedals = [];
                
                // 检查位置是否与任何禁区重叠
                function isPositionSafe(x, y) {
                    // 检查是否在任何禁区内
                    for (const zone of forbiddenZones) {
                        if (x >= zone.x && x <= zone.x + zone.width &&
                            y >= zone.y && y <= zone.y + zone.height) {
                                
                            return false;
                        }
                    }
                    
                    // 检查与已生成的金牌的距离
                    for (const medal of generatedMedals) {
                        const horizontalDistance = Math.abs(x - medal.x);
                        const verticalDistance = Math.abs(y - medal.y);
                        
                        // 检查横向距离
                        if (horizontalDistance < minMedalSpacing.horizontal* 0.6) {
                            // 如果横向距离小于最小间距，则检查是否存在纵向重叠
                            // 使用金牌尺寸加上安全距离确保完全没有纵向重叠
                            const medalHeightWithSafety = medal.height + minMedalSpacing.vertical * 0.8;
                            const thisHeightWithSafety = medalSize + minMedalSpacing.vertical * 0.8;
                            
                            // 检查纵向重叠
                            if (Math.abs((y + medalSize/2) - (medal.y + medal.height/2)) < (medalHeightWithSafety + thisHeightWithSafety) / 2) {
                                return false;
                            }
                        }
                    }
                    
                    return true;
                }
                
                // 生成金牌
                let medals = 0;
                let lastMedalX = paddingLeft;
                let attempts = 0;
                const maxAttempts = medalCount * 100; // 最大尝试次数
                
                // 设置金牌的基准高度
                const baseHeight = 270; // 基准高度设置在屏幕中间位置
                const heightVariation = 30; // 高度变化范围
                
                // 设置金牌的波动参数
                const waveLength = 1500; // 波长
                const waveAmplitude = 60; // 波幅
                
                // 跟踪上一个高度组和当前高度组，用于平滑过渡
                let lastHeightGroup = 1; // 从中间高度组开始
                
                while (medals < medalCount && attempts < maxAttempts) {
                    attempts++;
                    
                    // 确保金牌之间有足够的距离，增加随机性以让金牌分布更加自然
                    const avgSpacePerMedal = (levelLength - paddingLeft - paddingRight) / medalCount;
                    const distanceToNext = Math.max(
                        minMedalSpacing.horizontal * 0.8,
                        avgSpacePerMedal * (0.9 + Math.random() * 0.05)  // 减小随机性，确保均匀分布
                    );
                    
                    // 计算金牌的x坐标
                    const x = lastMedalX + distanceToNext;
                    
                    // 如果x超出了关卡长度，就重新开始
                    // 修改为：
                    if (x > levelLength - paddingRight) {
                        // 如果已经生成了足够多的金牌，就结束循环
                        if (medals >= medalCount) {
                            break;
                        }
                        // 否则继续尝试在剩余空间生成金牌
                        lastMedalX = levelLength - paddingRight - minMedalSpacing.horizontal;
                        continue;
                    }
                    
                    // 使用正弦波函数计算y坐标，实现平滑的上下起伏
                    // 通过关卡x位置计算波浪相位
                    const phase = x / waveLength * Math.PI * 2;
                    // 计算基于正弦波的高度偏移
                    const waveOffset = Math.sin(phase) * waveAmplitude;
                    
                    // 计算基础高度，加入小幅随机波动
                    const y = baseHeight + waveOffset + (Math.random() - 0.5) * heightVariation;
                    
                    // 检查是否是安全位置
                    if (isPositionSafe(x, y)) {
                        // 使用固定大小的金牌
                        const size = medalSize;
                        
                        // 保持浮动效果的随机性
                        const wobbleSpeed = 0.02 + Math.random() * 0.01;
                        const wobbleAmount = 4 + Math.random() * 3;
                        
                        // 将金牌信息添加到已生成列表
                        const medalInfo = {
                            x: x,
                            y: y,
                            width: size,
                            height: size
                        };
                        
                        generatedMedals.push(medalInfo);
                        
                        // 将金牌添加到游戏状态
                        gameState.stars.push({
                            x: x,
                            y: y,
                            width: size,
                            height: size,
                            collected: false,
                            wobble: {
                                speed: wobbleSpeed,
                                amount: wobbleAmount,
                                phase: Math.random() * Math.PI * 2
                            }
                        });
                        
                        lastMedalX = x;
                        medals++;
                    } else {
                        // 如果连续多次找不到安全位置，适当增加lastMedalX以跳过问题区域
                        if (attempts % 10 === 0) {
                            lastMedalX += minMedalSpacing.horizontal;
                        }
                    }
                }
                
                // 如果没有生成足够的金牌，在安全位置强制生成剩余的金牌
                if (medals < medalCount) {
                    console.log(`只生成了 ${medals} 个金牌，需要生成总共 ${medalCount} 个`);
                    
                    // 计算还需要生成的金牌数
                    const remainingMedals = medalCount - medals;
                    
                    // 在关卡全长范围内寻找安全位置
                    for (let i = 0; i < remainingMedals; i++) {
                        let safePositionFound = false;
                        let x, y;
                        
                        // 尝试最多30次找到安全位置
                        for (let attempt = 0; attempt < 50 && !safePositionFound; attempt++) {
                            // 随机生成位置，但保持在合理范围内
                            const remainingSpace = levelLength - lastMedalX - paddingRight;
                            x = 12000 + (i + 1) * ((17000 - 12000) / (remainingMedals + 1));
                            
                            // 添加少量随机性，但保持总体规则
                            x += (Math.random() - 0.5) * minMedalSpacing.horizontal * 0.2;
                            
                            // 使用与主生成相同的波浪函数
                            const phase = x / waveLength * Math.PI * 2;
                            const waveOffset = Math.sin(phase) * waveAmplitude;
                            y = baseHeight + waveOffset + (Math.random() - 0.5) * heightVariation;
                            
                            // 检查是否是安全位置
                            if (isPositionSafe(x, y)) {
                                safePositionFound = true;
                            }
                        }
                        
                        // 如果找到安全位置，添加金牌
                        if (safePositionFound) {
                            const size = medalSize;
                            const wobbleSpeed = 0.02 + Math.random() * 0.01;
                            const wobbleAmount = 4 + Math.random() * 3;
                            
                            // 将金牌信息添加到已生成列表
                            const medalInfo = {
                                x: x,
                                y: y,
                                width: size,
                                height: size
                            };
                            
                            generatedMedals.push(medalInfo);
                            
                            gameState.stars.push({
                                x: x,
                                y: y,
                                width: size,
                                height: size,
                                collected: false,
                                wobble: {
                                    speed: wobbleSpeed,
                                    amount: wobbleAmount,
                                    phase: Math.random() * Math.PI * 2
                                }
                            });
                            
                            medals++;
                        }
                    }
                }
                
                // 如果最终生成的金牌数量小于目标数量，打印警告
                if (gameState.stars.length < medalCount) {
                    console.warn(`警告：只生成了 ${gameState.stars.length} 个金牌，少于目标数量 ${medalCount}`);
                } else {
                    console.log(`成功生成了 ${gameState.stars.length} 个金牌`);
                }
            }

            // 修改updateParticles函数
            function updateParticles() {
                // 更新粒子状态
                for (let i = gameState.particles.length - 1; i >= 0; i--) {
                    const p = gameState.particles[i];
                    
                    // 减少生命值
                    p.life -= 60 * gameState.time.elapsed; // 基于时间的生命减少
                    
                    if (p.life <= 0) {
                        // 特殊处理 - 在胜利场景中自动重生金币雨粒子
                        if (p.isGoldRain && p.type === 'coin' && 
                            gameState.victoryPending && !gameState.victory) {
                            // 恢复一些生命值，但逐渐减少恢复量以实现自然消失效果
                            const recoveryRate = 0.7; // 恢复率，小于1以确保最终会消失
                            p.life = Math.max(10, Math.floor(p.maxLife * recoveryRate * (gameState.victoryDelay / 600)));
                        } else {
                            gameState.particles.splice(i, 1);
                            continue;
                        }
                    }
                    
                    // 应用重力 (如果粒子有重力属性) - 基于时间
                    if (p.gravity) {
                        p.velocityY += p.gravity * 60 * gameState.time.elapsed;
                    }
                    
                    // 应用摩擦力 (如果粒子有摩擦力属性) - 基于时间
                    if (p.friction) {
                        // 时间相关的指数衰减
                        p.velocityX *= Math.pow(p.friction, 60 * gameState.time.elapsed);
                        p.velocityY *= Math.pow(p.friction, 60 * gameState.time.elapsed);
                    }
                    
                    // 更新位置 - 基于时间
                    p.x += p.velocityX * 60 * gameState.time.elapsed;
                    p.y += p.velocityY * 60 * gameState.time.elapsed;
                    
                    // 更新旋转 - 基于时间
                    if (p.rotationSpeed) {
                        p.rotation += p.rotationSpeed * 60 * gameState.time.elapsed;
                    }
                    
                    // 扩展环效果 - 基于时间
                    if (p.isRing && p.expansionRate) {
                        p.radius += p.expansionRate * 60 * gameState.time.elapsed;
                        // 随着扩展，透明度降低
                        if (p.color && typeof p.color === 'string' && p.color.startsWith('rgba')) {
                            const parts = p.color.split(',');
                            if (parts.length >= 4) {
                                const alpha = parseFloat(parts[3]) * 0.95;
                                parts[3] = alpha + ')';
                                p.color = parts.join(',');
                            }
                        }
                    }
                    
                    // 金币和星星粒子的特殊碰撞处理 - 在接触地面时反弹
                    if ((p.type === 'coin' || p.type === 'star' || p.type === 'diamond') && !p.bounced) {
                        // 确定粒子底部的世界坐标
                        const bottomY = p.y + p.size;
                        
                        // 对于金币雨粒子，我们使用屏幕底部作为地面
                        const groundY = p.isGoldRain ? 
                            (canvas.height + gameState.camera.y - 10) : // 屏幕底部稍微上方
                            gameState.endPlatform.y; // 对于普通粒子使用终点平台
                        
                        // 如果粒子触底并且还未反弹过
                        if (bottomY >= groundY && p.velocityY > 0) {
                            // 反弹时，速度减小
                            p.velocityY = -p.velocityY * 0.4;
                            
                            // 如果垂直速度很小，则停止反弹
                            if (Math.abs(p.velocityY) < 0.5) {
                                p.velocityY = 0;
                                p.velocityX *= 0.9; // 减慢水平移动
                                p.bounced = true; // 标记已反弹，不再处理
                            }
                            
                            // 调整水平速度
                            p.velocityX *= 0.8;
                        }
                    }
                }
            }

            function drawParticles() {
                for (let i = 0; i < gameState.particles.length; i++) {
                    const p = gameState.particles[i];
                    
                    // 跳过不在屏幕范围内的粒子
                    const screenX = p.x - gameState.camera.x;
                    const screenY = p.y - gameState.camera.y;
                    
                    if (screenX < -50 || screenX > canvas.width + 50 || 
                        screenY < -50 || screenY > canvas.height + 50) {
                        continue;
                    }
                    
                    ctx.save();
                    
                    // 应用粒子的旋转
                    ctx.translate(screenX, screenY);
                    ctx.rotate(p.rotation || 0);
                    
                    // 绘制不同类型的粒子
                    if (p.type === 'bubble') {
                        // 气泡破裂效果
                        const alpha = p.life / p.maxLife;
                        ctx.strokeStyle = `rgba(255, 255, 255, ${alpha * 0.8})`;
                        ctx.lineWidth = 1.5;
                        ctx.beginPath();
                        ctx.arc(0, 0, p.size, 0, Math.PI * 2);
                        ctx.stroke();
                    } else if (p.type === 'coin') {
                        // 金币效果 - 根据旋转角度改变形状模拟3D效果
                        const coinWidth = p.size * 1.2;
                        const coinHeight = p.size * (0.2 + Math.abs(Math.sin(p.rotation)) * 0.8);
                        const opacity = p.life / p.maxLife;
                        
                        // 金币主体
                        ctx.fillStyle = `rgba(255, 215, 0, ${opacity})`;
                        ctx.beginPath();
                        ctx.ellipse(0, 0, coinWidth/2, coinHeight/2, 0, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // 金币轮廓
                        ctx.strokeStyle = `rgba(255, 165, 0, ${opacity})`;
                        ctx.lineWidth = 1;
                        ctx.stroke();
                        
                        // 金币高光
                        ctx.fillStyle = `rgba(255, 255, 200, ${opacity * 0.6})`;
                        ctx.beginPath();
                        ctx.ellipse(-coinWidth/4, -coinHeight/4, coinWidth/8, coinHeight/8, 0, 0, Math.PI * 2);
                        ctx.fill();
                    } else if (p.type === 'star') {
                        // 星星效果
                        const opacity = p.life / p.maxLife;
                        const starSize = p.size * (0.7 + Math.sin(gameState.frameCount * 0.2) * 0.3);
                        
                        ctx.fillStyle = `rgba(255, 255, 0, ${opacity})`;
                        ctx.beginPath();
                        
                        // 绘制五角星
                        for (let i = 0; i < 5; i++) {
                            const angle = (i * Math.PI * 2 / 5) - Math.PI / 2;
                            const distance = i === 0 ? starSize : starSize * 0.4;
                            const x = Math.cos(angle) * distance;
                            const y = Math.sin(angle) * distance;
                            
                            if (i === 0) {
                                ctx.moveTo(x, y);
                            } else {
                                ctx.lineTo(x, y);
                            }
                        }
                        ctx.closePath();
                        ctx.fill();
                        
                        // 星星轮廓
                        ctx.strokeStyle = `rgba(255, 200, 0, ${opacity})`;
                        ctx.lineWidth = 1;
                        ctx.stroke();
                    } else if (p.type === 'diamond') {
                        // 钻石效果
                        const opacity = p.life / p.maxLife;
                        
                        // 钻石主体
                        ctx.fillStyle = `rgba(0, 191, 255, ${opacity})`;
                        ctx.beginPath();
                        ctx.moveTo(0, -p.size);
                        ctx.lineTo(p.size * 0.7, 0);
                        ctx.lineTo(0, p.size);
                        ctx.lineTo(-p.size * 0.7, 0);
                        ctx.closePath();
                        ctx.fill();
                        
                        // 钻石轮廓
                        ctx.strokeStyle = `rgba(135, 206, 250, ${opacity})`;
                        ctx.lineWidth = 1;
                        ctx.stroke();
                        
                        // 钻石高光
                        ctx.fillStyle = `rgba(255, 255, 255, ${opacity * 0.7})`;
                        ctx.beginPath();
                        ctx.moveTo(-p.size * 0.2, -p.size * 0.2);
                        ctx.lineTo(p.size * 0.2, -p.size * 0.2);
                        ctx.lineTo(0, p.size * 0.2);
                        ctx.closePath();
                        ctx.fill();
                    } else {
                        // 默认粒子效果 - 处理直接指定颜色字符串的情况
                        const alpha = p.life / (p.maxLife || p.life * 2);
                        if (typeof p.color === 'string') {
                            // 直接使用颜色字符串(如 'rgba(200, 230, 250, 0.5)')
                            ctx.fillStyle = p.color;
                        } else {
                            // 使用RGB格式(如 '200, 230, 250')
                            ctx.fillStyle = `rgba(${p.color}, ${alpha})`;
                        }
                        ctx.beginPath();
                        ctx.arc(0, 0, p.radius || p.size, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    ctx.restore();
                }
            }
            
            // 碰撞检测
            function checkCollision(rect1, rect2) {
                return rect1.x < rect2.x + rect2.width &&
                    rect1.x + rect1.width > rect2.x &&
                    rect1.y < rect2.y + rect2.height &&
                    rect1.y + rect1.height > rect2.y;
            }

            // 修改生成新气泡函数
            function spawnBubble(spawner) {
                const x = spawner.x + Math.random() * spawner.width;
                const size = 60 + Math.random() * 30;
                
                // 获取当前时间，用于判断是否是游戏开始后的第一波气泡
                const currentTime = Date.now();
                const gameStartTime = gameState.gameStartTime || currentTime;
                
                // 判断是否是游戏开始后的前10秒内生成的气泡
                const isFirstWaveBubble = (currentTime - gameStartTime) < 5000; // 10秒内的气泡视为第一波
                
                // 根据是否是第一波气泡调整速度
                // 第一波气泡速度是普通气泡的1.8倍，以便快速到达玩家位置
                const baseSpeed = 0.6 + Math.random() * 0.4; // 普通气泡的基础速度
                const speed = isFirstWaveBubble ? baseSpeed * 1.8 : baseSpeed;
                
                gameState.platforms.push({
                    x: x,
                    y: spawner.spawnY,
                    width: size,
                    height: size,
                    radius: size / 2,
                    speed: speed,
                    isFirstWave: isFirstWaveBubble, // 标记是否为第一波气泡
                    opacity: 0.4 + Math.random() * 0.3,
                    isPopping: false,
                    isSinking: false,
                    popProgress: 0,
                    scale: 1,
                    wobbleOffset: Math.random() * Math.PI * 2,
                    wobbleSpeed: 0.02 + Math.random() * 0.02
                });
            }

            // 更新平台动画
            function updatePlatforms(elapsed) {
                const currentTime = Date.now();
                
                // 检查气泡生成点
                for (const spawner of gameState.bubbleSpawners) {
                    if (currentTime - spawner.lastSpawn > spawner.interval) {
                        spawnBubble(spawner);
                        spawner.lastSpawn = currentTime;
                    }
                }

                // 更新现有气泡 - 使用基于时间的移动
                for (let i = gameState.platforms.length - 1; i >= 0; i--) {
                    const platform = gameState.platforms[i];
                    
                    if (platform.isPopping) {
                        // 处理破裂动画 - 基于时间的动画进度
                        platform.popProgress += 0.1 * 60 * elapsed;
                        platform.scale += 0.2 * 60 * elapsed;
                        platform.opacity *= Math.pow(0.8, 60 * elapsed);
                        
                        if (platform.popProgress >= 1) {
                            gameState.platforms.splice(i, 1);
                            continue;
                        }
                    } else if (platform.isSinking) {
                        // 处理下沉状态 - 基于时间的下沉速度
                        platform.y += 0.7 * 60 * elapsed; // 使用时间缩放
                        if (platform.y > canvas.height + 50) {
                            gameState.platforms.splice(i, 1);
                            continue;
                        }
                    } else {
                        // 正常上升 - 基于时间的上升速度
                        platform.y -= platform.speed * 60 * elapsed;
                        
                        // 横向摆动 - 基于时间的摆动
                        // 为第一波气泡增加更快的横向摆动速度
                        const wobbleMultiplier = platform.isFirstWave ? 1.5 : 1.0; // 第一波气泡摆动速度更快
                        platform.x += Math.sin(platform.wobbleOffset) * 0.4 * 60 * elapsed * wobbleMultiplier;
                        platform.wobbleOffset += platform.wobbleSpeed * 0.8 * 60 * elapsed * wobbleMultiplier;
                    }

                    // 超出屏幕顶部时移除
                    if (platform.y < -50) {
                        gameState.platforms.splice(i, 1);
                    }
                }
            }

            // 检查平台碰撞
            function checkPlatformCollision() {
                // 检查终点平台
                const endPlatform = gameState.endPlatform;
                    if (gameState.player.velocityY > 0 && 
                    gameState.player.y + gameState.player.height <= endPlatform.y + 5 && 
                    gameState.player.y + gameState.player.height + gameState.player.velocityY >= endPlatform.y - 5 &&
                    gameState.player.x + gameState.player.width > endPlatform.x && 
                    gameState.player.x < endPlatform.x + endPlatform.width) {
                    
                    gameState.player.y = endPlatform.y - gameState.player.height;
                    gameState.player.velocityY = 0;
                    gameState.player.isJumping = false;
                    gameState.player.jumpCount = 0;
                    
                    // 记录终点平台
                    recordSteppedPlatform(endPlatform);
                    
                    // 添加日志：触发终点平台
                    console.log("触发终点平台，宝箱状态:", gameState.chest.isAnimating, gameState.chest.isOpened);
                    
                    // 如果宝箱还没开启动画，开始播放
                    if (!gameState.chest.isAnimating && !gameState.chest.isOpened) {
                        console.log("开始播放宝箱开启动画");
                        gameState.chest.isAnimating = true;
                        gameState.chest.currentFrame = 0; // 确保从第一帧开始播放
                        
                        // 设置胜利准备状态，但不立即进入胜利状态
                        if (!gameState.victoryPending) {
                            gameState.victoryPending = true;
                            
                            // 检查是否为全收集特殊状态
                            const isFullCollection = gameState.player.collected === gameState.stars.length && gameState.stars.length > 0;
                            
                            // 全收集状态下延长胜利延迟到10秒
                            gameState.victoryDelay = isFullCollection ? 600 : 300; // 10秒或5秒 (60帧/秒)
                            
                            // 标记是否为全收集特殊状态
                            gameState.isFullCollection = isFullCollection;
                            
                            console.log("胜利准备中 - " + (isFullCollection ? "全收集特殊状态(10秒延迟)" : "普通状态(5秒延迟)"));
                        }
                    }
                    
                    return true;
                }

                // 检查固定平台
                for (const platform of gameState.staticPlatforms) {
                    if (gameState.player.velocityY > 0 && 
                        gameState.player.y + gameState.player.height <= platform.y + 5 && 
                        gameState.player.y + gameState.player.height + gameState.player.velocityY >= platform.y - 5 &&
                        gameState.player.x + gameState.player.width > platform.x && 
                        gameState.player.x < platform.x + platform.width) {
                        
                        gameState.player.y = platform.y - gameState.player.height;
                        gameState.player.velocityY = 0;
                        gameState.player.isJumping = false;
                        gameState.player.jumpCount = 0;
                        
                        // 记录踩踏的固定平台
                        recordSteppedPlatform(platform);
                        
                        return true;
                    }
                }

                // 检查气泡平台 - 增加碰撞宽容度
                for (const platform of gameState.platforms) {
                    // 仅处理非破裂的气泡
                    if (platform.isPopping) continue;
                    
                    // 获取平台中心点
                    const platformCenterX = platform.x + platform.width / 2;
                    const platformCenterY = platform.y + platform.height / 2;
                    
                    // 获取玩家底部中心点
                    const playerBottomCenterX = gameState.player.x + gameState.player.width / 2;
                    const playerBottomY = gameState.player.y + gameState.player.height;
                    
                    // 计算距离
                    const dx = playerBottomCenterX - platformCenterX;
                    const dy = playerBottomY - platformCenterY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    // 有效半径为气泡直径的60%
                    const effectiveRadius = (platform.width / 2) * 0.6;
                    
                    // 玩家正在下落且接近气泡表面
                    if (gameState.player.velocityY > 0 && 
                        distance < effectiveRadius && 
                        playerBottomY <= platformCenterY) {
                        
                        // 调整玩家位置到气泡表面
                        gameState.player.y = platformCenterY - effectiveRadius - gameState.player.height + 5;
                        gameState.player.velocityY = 0;
                        gameState.player.isJumping = false;
                        gameState.player.jumpCount = 0;
                        platform.isSinking = true;  // 开始下沉
                        
                        // 气泡平台不记录，因为它们是临时的
                        
                        return true;
                    }
                }
                return false;
            }

            // 添加记录踩踏平台的辅助函数
            function recordSteppedPlatform(platform) {
                // 创建平台的简单副本
                const platformInfo = {
                    x: platform.x,
                    y: platform.y,
                    width: platform.width,
                    height: platform.height,
                    color: platform.color || '#5a7a95'
                };
                
                // 检查是否已经记录过这个平台
                const existingIndex = gameState.player.lastSteppedPlatforms.findIndex(p => 
                    p.x === platform.x && p.y === platform.y
                );
                
                if (existingIndex !== -1) {
                    // 如果已存在，将它移到列表最前面（最近踩踏）
                    gameState.player.lastSteppedPlatforms.splice(existingIndex, 1);
                }
                
                // 添加到踩踏平台记录的开头，保留最近的5个记录
                gameState.player.lastSteppedPlatforms.unshift(platformInfo);
                if (gameState.player.lastSteppedPlatforms.length > 5) {
                    gameState.player.lastSteppedPlatforms.pop();
                }
                
                console.log("记录平台:", platform.x, platform.y, "当前记录数:", gameState.player.lastSteppedPlatforms.length);
            }

            // 移除墙壁碰撞检测函数
            function checkWallCollision() {
                // 已移除墙壁，此函数现为空，保留以防其他地方调用
            }

            // 重命名函数
            function checkMedalCollision() {
                if (!gameState.stars || gameState.stars.length === 0) return;
                
                for (let i = 0; i < gameState.stars.length; i++) {
                    const star = gameState.stars[i];
                    if (!star.collected && checkCollision(gameState.player, star)) {
                        star.collected = true;
                        gameState.player.collected++;
                        
                        try {
                            // 首先创建特效
                            createMedalParticles(star.x + star.width/2, star.y + star.height/2);
                            
                            // 然后播放音效，使用异步方式避免阻塞
                            setTimeout(() => {
                                playSound('collectCoin');
                            }, 0);
                        } catch (error) {
                            console.error("收集金币时出错:", error);
                            // 出错时也要确保游戏继续运行
                        }
                    }
                }
            }

            function checkChestCollision() {
                // 当玩家直接碰到宝箱时
                if (checkCollision(gameState.player, gameState.chest) && 
                   (gameState.stars.length === 0 || gameState.player.collected === gameState.stars.length)) {
                    
                    // 如果宝箱还没开启动画，开始播放
                    if (!gameState.chest.isAnimating && !gameState.chest.isOpened) {
                        console.log("宝箱碰撞检测 - 开始播放宝箱开启动画");
                        gameState.chest.isAnimating = true;
                        gameState.chest.currentFrame = 0; // 确保从第一帧开始播放
                        
                        // 设置胜利准备状态，但不立即进入胜利状态
                        if (!gameState.victoryPending) {
                            gameState.victoryPending = true;
                            gameState.victoryDelay = 300; // 延长到5秒的延迟(60帧/秒)
                        }
                    }
                }
            }

            // 更新动画
            function updateAnimation(elapsed) {
                const player = gameState.player;
                if (!player.sprite) return;

                // 计算与移动速度相关的动画速度
                let animationSpeedMultiplier = 1.0;
                
                // 根据状态调整动画速度
                if (player.isRunning) {
                    // 走路/跑步时，确保有最小动画速度，即使短距离移动也能看到明显走路姿态
                    const minSpeedMultiplier = 15; // 设置最小动画速度倍率
                    animationSpeedMultiplier = Math.max(minSpeedMultiplier, Math.abs(player.velocityX) / player.speed);
                } else if (player.isJumping) {
                    // 跳跃时使用固定的动画速度
                    animationSpeedMultiplier = 0.7;
                } else {
                    // 站立时动画速度非常慢，几乎不变
                    animationSpeedMultiplier = 0.3;
                }
                
                // 累计时间，使用实际经过的时间乘以合适的速度倍率
                // 增加基础动画速度，从0.05提高到0.08
                player.animationTimer += elapsed * 0.08 * animationSpeedMultiplier;
                
                // 根据状态选择正确的动画行
                if (player.isJumping) {
                    // 跳跃动画
                    player.currentRow = 1;  // 使用第二行动画（跳跃）
                } else if (player.isRunning) {
                    // 走路/跑步动画
                    player.currentRow = 0;  // 使用第一行动画（跑步）
                } else {
                    // 站立动画
                    player.currentRow = 0;  // 使用第一行动画（静止）
                }

                // 使用更短的走路动画帧持续时间
                // 走路动画帧切换更快，跳跃和站立保持原速
                const baseDuration = 0.2; // 基本帧持续时间
                const frameDuration = player.isRunning ? baseDuration * 1.5 : baseDuration; // 走路时加快帧切换40%
                
                // 更新动画帧
                if (player.animationTimer >= frameDuration) {
                    // 重置计时器，但保留溢出时间以保持平滑
                    player.animationTimer = player.animationTimer % frameDuration;
                    
                    if (player.isRunning || player.isJumping) {
                        // 跑步或跳跃时循环播放动画
                        player.currentFrame = (player.currentFrame + 1) % player.frameCount;
                    } else {
                        // 站立时显示第一帧或呼吸动画
                        player.currentFrame = 0;  // 静止时显示第一帧
                    }
                }
            }

            // 修改update函数，扩展相机范围
            function update() {
                if (gameState.gameOver || gameState.victory || !gameState.gameStarted) return;
                
                // 检查是否需要将气泡生成器恢复到正常间隔
                const currentTime = Date.now();
                if (gameState.gameStartTime && !gameState.bubbleIntervalNormalized) {
                    // 游戏开始后15秒恢复正常气泡生成间隔
                    if (currentTime - gameState.gameStartTime > 2000) {
                        // 恢复所有气泡生成器的正常间隔
                        for (const spawner of gameState.bubbleSpawners) {
                            spawner.interval = spawner.normalInterval || spawner.interval;
                        }
                        gameState.bubbleIntervalNormalized = true;
                        console.log("气泡生成器恢复正常间隔");
                    }
                }
                
                // 使用时间系统而不是固定帧率
                updatePlatforms(gameState.time.elapsed);
                updateTeas(); // 更新茶收集物
                
                // 更新宝箱动画
                updateChestAnimation(gameState.time.elapsed);
                
                // 更新宝箱闪光效果
                updateChestGlowEffects();
                
                // 更新金币雨效果
                updateGoldRainEffect();
                
                // 更新粒子效果
                updateParticles();
                
                // 处理胜利延迟 - 基于时间
                if (gameState.victoryPending) {
                    // 之前是每帧减1，现在基于实际时间
                    gameState.victoryDelay -= 60 * gameState.time.elapsed; // 60帧/秒的等效
                    
                    // 如果延迟结束，设置胜利状态
                    if (gameState.victoryDelay <= 0) {
                        gameState.victory = true;
                        gameState.victoryPending = false;
                        console.log("胜利延迟结束，显示胜利画面");
                        return; // 停止更新，进入胜利状态
                    }
                }
                
                // 更新玩家的茶特效
                updateTeaEffect(gameState.player);

                const player = gameState.player;

                // 处理初始气泡状态
                if (player.onStartBubble) {
                    // 如果没有初始气泡，创建它
                    if (!gameState.startBubble) {
                        gameState.startBubble = {
                            x: player.x - 10,
                            y: player.y + 10,
                            width: 80,
                            height: 80,
                            scale: 1,
                            opacity: 0.8,
                            isSinking: false, // 初始不下沉
                            sinkSpeed: 0.1,   // 减慢下沉速度
                            isPopping: false,
                            wobble: {
                                amount: 0.8,
                                speed: 0.03
                            }
                        };
                    }
                    
                    // 更新初始气泡位置 - 添加漂浮效果
                    const bubble = gameState.startBubble;
                    
                    // 缓慢下沉 - 基于时间
                    bubble.y += bubble.sinkSpeed * 60 * gameState.time.elapsed;
                    
                    // 水平摆动效果
                    const wobbleX = Math.sin(gameState.frameCount * bubble.wobble.speed) * bubble.wobble.amount;
                    bubble.x += wobbleX * 0.1; // 平滑的左右摆动
                    
                    // 玩家跟随气泡
                    player.x = bubble.x + 10;
                    player.y = bubble.y - player.height + 5;
                    
                    // 应用轻微的摆动效果
                    player.x += wobbleX * 0.5;
                    
                    // 检测玩家移动或跳跃输入，此时结束初始气泡状态
                    if (gameState.keys.left || gameState.keys.right || gameState.keys.jump) {
                        player.onStartBubble = false;
                        
                        // 气泡破裂
                        bubble.isPopping = true;
                        createBubblePopParticles(bubble);
                        
                        // 玩家处于跳跃状态
                        player.isJumping = true;
                        player.velocityY = -player.jumpForce * 0.7; // 给予一个向上初速度
                    }
                    
                    // 如果气泡下沉到一定程度，自动结束初始状态
                    if (bubble.y > 350) {
                        // 开始下沉得更快
                        bubble.sinkSpeed = 0.3;
                    }
                    
                    if (bubble.y > 500) {
                        player.onStartBubble = false;
                        // 气泡破裂
                        bubble.isPopping = true;
                        createBubblePopParticles(bubble);
                    }
                    
                    // 如果气泡正在破裂，移除它
                    if (bubble.isPopping) {
                        gameState.startBubble = null;
                    }
                } else {
                    // 正常的玩家移动逻辑
                // 水平移动
                player.velocityX = 0;
                    
                    if (gameState.keys.right) {
                        player.velocityX = player.speed;
                        player.facingRight = true;
                    }
                if (gameState.keys.left) {
                    player.velocityX = -player.speed;
                    player.facingRight = false;
                }
                    
                    // 更新玩家动画状态，确保只有当不在跳跃状态时才设置为走路
                    if (player.velocityX !== 0) {
                        // 只有当玩家不在跳跃状态时才设置为走路状态
                        if (!player.isJumping) {
                            player.isRunning = true;
                        } else {
                            // 跳跃中即使有水平移动也不是走路状态
                            player.isRunning = false;
                        }
                    } else {
                        player.isRunning = false;
                    }
                    
                    // 应用重力
                    player.velocityY += player.gravity;
                    
                    // 跳跃处理
                if (gameState.keys.jump) {
                    if (!player.isJumping) {
                        player.velocityY = -player.jumpForce;
                        player.isJumping = true;
                        player.jumpCount = 1;
                            // 检查并破裂当前站立的气泡
                            for (const platform of gameState.platforms) {
                                if (platform.isSinking && 
                                    player.x + player.width > platform.x && 
                                    player.x < platform.x + platform.width) {
                                    platform.isPopping = true;
                                    platform.isSinking = false;
                                    createBubblePopParticles(platform);
                                    break;
                                }
                            }
                    } else if (player.jumpCount < player.maxJumps) {
                        player.velocityY = -player.jumpForce * 0.8;
                        player.jumpCount++;
                    }
                    gameState.keys.jump = false;
                }

                // 更新位置
                player.x += player.velocityX;
                player.y += player.velocityY;
                }

                // 检测碰撞
                checkPlatformCollision();
                checkMedalCollision();
                checkTeaCollision(); // 检查茶碰撞
                checkChestCollision(); // 替换为检查宝箱碰撞
                checkSpikesCollision(); // 检查尖刺碰撞
                
                // 更新相机位置
                const targetX = player.x - canvas.width / 3; // 让玩家保持在屏幕左侧1/3处
                
                // 使用平滑插值，根据玩家是否刚复活调整平滑系数
                let smoothFactor = 0.1; // 默认平滑系数
                
                // 检测玩家是否刚复活（通过茶道具特效判断）
                if (player.teaEffect.active && player.teaEffect.duration < 10) {
                    // 刚复活时使用更小的平滑系数，使镜头移动更加缓慢
                    smoothFactor = 0.000003;
                }
                
                // 计算相机位置差值，并应用平滑因子
                gameState.camera.x += (targetX - gameState.camera.x) * smoothFactor;
                
                // 防止相机移出关卡左边界
                if (gameState.camera.x < 0) {
                    gameState.camera.x = 0;
                }
                
                // 移除相机右侧边界限制，确保玩家可以继续向前移动
                // 确保相机可以跟随玩家到关卡的最远处（终点附近）
                const maxCameraX = 17100 - canvas.width + 100; // 调整终点平台位置加一些余量
                if (gameState.camera.x > maxCameraX) {
                    gameState.camera.x = maxCameraX;
                }

                // 掉落检测
                if (player.y > canvas.height) {
                    // 创建玩家掉落粒子效果
                    createFallEffect(player.x + player.width/2, canvas.height - 50);
                    
                    // 检查是否有茶道具可用
                    if (gameState.collectedTeas > 0) {
                        // 找到最近踩踏过的固定平台
                        let respawnPlatform = null;
                        
                        if (player.lastSteppedPlatforms.length > 0) {
                            // 使用最近踩踏的平台
                            respawnPlatform = player.lastSteppedPlatforms[0];
                            console.log("复活到最近踩踏的平台:", respawnPlatform.x, respawnPlatform.y);
                        } else {
                            // 如果没有踩踏记录，继续使用原来的查找最近平台的方法
                            respawnPlatform = findNearestStaticPlatform(player.x);
                            console.log("没有踩踏记录，复活到最近的平台:", respawnPlatform ? respawnPlatform.x : "无平台");
                        }
                        
                        if (respawnPlatform) {
                            // 消耗一个茶道具
                            gameState.collectedTeas--;
                            
                            // 在固定平台上复活玩家
                            player.x = respawnPlatform.x + respawnPlatform.width / 2 - player.width / 2;
                            player.y = respawnPlatform.y - player.height;
                            player.velocityY = 0;
                            player.isJumping = false;
                            
                            // 创建复活特效
                            createRespawnEffect(player.x + player.width/2, player.y + player.height/2);
                            
                            // 激活茶效果状态
                            activateTeaEffect(player);
                            
                            // 不重置收集物状态，保持坠落时的样子
                        } else {
                            // 没有找到合适的平台，在起点复活并消耗茶道具
                            gameState.collectedTeas--;
                    player.x = 50;
                            player.y = 300;  // 修改复活高度
                    player.velocityY = 0;
                            player.isJumping = false;
                            createRespawnEffect(player.x + player.width/2, player.y + player.height/2);
                            
                            // 激活茶效果状态
                            activateTeaEffect(player);
                        }
                    } else {
                        // 没有茶道具，游戏结束
                        gameState.gameOver = true;
                        
                        // 播放游戏失败音效
                        playSound('gameOver');
                        
                        // 添加点击事件监听，用于重新开始游戏
                        if (!gameState.restartListenerAdded) {
                            canvas.addEventListener('click', restartGame);
                            canvas.addEventListener('touchstart', restartGame);
                            gameState.restartListenerAdded = true;
                        }
                    }
                }

                // 更新粒子
                updateParticles();
                
                // 更新玩家动画
                updateAnimation(gameState.time.elapsed);
                
                // 增加帧计数
                gameState.frameCount++;
            }

            // 修改破裂粒子效果
            function createBubblePopParticles(platform) {
                const particleCount = 15; // 减少粒子数量
                const centerX = platform.x + platform.width/2;
                const centerY = platform.y + platform.height/2;
                const radius = Math.min(platform.width, platform.height) / 2 * platform.scale;
                
                // 播放气泡破裂音效
                playSound('bubblePop');
                
                for (let i = 0; i < particleCount; i++) {
                    const angle = (Math.PI * 2 * i) / particleCount;
                    const distance = radius * 0.8;
                    const startX = centerX + Math.cos(angle) * distance;
                    const startY = centerY + Math.sin(angle) * distance;
                    const speed = 1 + Math.random() * 1.5;
                    
                    gameState.particles.push({
                        x: startX,
                        y: startY,
                        radius: 1 + Math.random() * 2,
                        color: 'rgba(200, 230, 250, 0.5)', // 更透明的颜色
                        velocityX: Math.cos(angle) * speed,
                        velocityY: Math.sin(angle) * speed,
                        life: 15 + Math.random() * 10 // 减少粒子寿命
                    });
                }
                
                // 添加一些小水滴粒子 - 更透明
                for (let i = 0; i < 5; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 0.5 + Math.random() * 1.5;
                    
                    gameState.particles.push({
                        x: centerX,
                        y: centerY,
                        radius: 2 + Math.random() * 1.5,
                        color: 'rgba(180, 220, 245, 0.4)', // 更透明的颜色
                        velocityX: Math.cos(angle) * speed,
                        velocityY: Math.sin(angle) * speed + 2,
                        life: 25 + Math.random() * 15
                    });
                }
            }

            // 更新气泡渲染，添加更明显的可踩踏指示
            function drawPlatform(platform) {
                const x = platform.x - gameState.camera.x;
                const y = platform.y - gameState.camera.y;
                
                ctx.save();
                
                const radius = Math.min(platform.width, platform.height) / 2 * platform.scale;
                
                // 绘制完美圆形的气泡 - 更清透版本
                if (platform.isPopping) {
                    // 破裂时的气泡
                    // 创建气泡内部渐变
                    const gradient = ctx.createRadialGradient(
                        x + platform.width/2, y + platform.height/2, 0,
                        x + platform.width/2, y + platform.height/2, radius
                    );
                    gradient.addColorStop(0, `rgba(255, 255, 255, ${platform.opacity * 0.3})`);
                    gradient.addColorStop(0.7, `rgba(220, 240, 255, ${platform.opacity * 0.15})`);
                    gradient.addColorStop(1, `rgba(200, 220, 255, ${platform.opacity * 0.05})`);
                    
                    // 填充气泡内部
                    ctx.beginPath();
                    ctx.arc(
                        x + platform.width/2,
                        y + platform.height/2,
                        radius,
                        0, Math.PI * 2
                    );
                    ctx.fillStyle = gradient;
                    ctx.fill();
                } else {
                    // 正常气泡的绘制 - 更清透明亮
                    
                    // 先绘制更透明的内部填充
                    const fillGradient = ctx.createRadialGradient(
                        x + platform.width/2, y + platform.height/2, 0,
                        x + platform.width/2, y + platform.height/2, radius
                    );
                    fillGradient.addColorStop(0, `rgba(250, 253, 255, ${platform.opacity * 0.2})`);
                    fillGradient.addColorStop(0.6, `rgba(235, 245, 255, ${platform.opacity * 0.1})`);
                    fillGradient.addColorStop(1, `rgba(220, 240, 255, ${platform.opacity * 0.05})`);
                    
                    ctx.beginPath();
                    ctx.arc(
                        x + platform.width/2,
                        y + platform.height/2,
                        radius,
                        0, Math.PI * 2
                    );
                    ctx.fillStyle = fillGradient;
                    ctx.fill();
                    
                    // 绘制更锐利的气泡边缘
                    ctx.beginPath();
                    ctx.arc(
                        x + platform.width/2,
                        y + platform.height/2,
                        radius,
                        0, Math.PI * 2
                    );
                    ctx.strokeStyle = `rgba(255, 255, 255, ${platform.opacity * 0.9})`;
                    ctx.lineWidth = 1;
                    ctx.stroke();
                    
                    // 强化气泡高光点 - 更加明亮
                    const highlightRadius = radius * 0.2;
                    ctx.beginPath();
                    ctx.arc(
                        x + platform.width/2 - radius * 0.35,
                        y + platform.height/2 - radius * 0.35,
                        highlightRadius,
                        0, Math.PI * 2
                    );
                    
                    // 创建明亮高光渐变
                    const highlightGradient = ctx.createRadialGradient(
                        x + platform.width/2 - radius * 0.35,
                        y + platform.height/2 - radius * 0.35,
                        0,
                        x + platform.width/2 - radius * 0.35,
                        y + platform.height/2 - radius * 0.35,
                        highlightRadius
                    );
                    highlightGradient.addColorStop(0, `rgba(255, 255, 255, ${platform.opacity * 0.9})`);
                    highlightGradient.addColorStop(1, `rgba(255, 255, 255, 0)`);
                    
                    ctx.fillStyle = highlightGradient;
                    ctx.fill();
                    
                    // 添加小反光点 - 更明亮锐利
                    ctx.beginPath();
                    ctx.arc(
                        x + platform.width/2 - radius * 0.3,
                        y + platform.height/2 - radius * 0.3,
                        radius * 0.05,
                        0, Math.PI * 2
                    );
                    ctx.fillStyle = `rgba(255, 255, 255, ${platform.opacity * 1.0})`;
                    ctx.fill();
                    
                    // 添加第二个小反光点增强晶莹感
                    ctx.beginPath();
                    ctx.arc(
                        x + platform.width/2 + radius * 0.15,
                        y + platform.height/2 - radius * 0.2,
                        radius * 0.03,
                        0, Math.PI * 2
                    );
                    ctx.fillStyle = `rgba(255, 255, 255, ${platform.opacity * 0.9})`;
                    ctx.fill();
                }
                
                ctx.restore();
            }

            // 绘制游戏
            function render() {
                // 清除画布
                ctx.fillStyle = '#0f1631'; // 蔚蓝风格背景色
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // 绘制海底场景 - 始终绘制，包括开始界面
                drawPirateScene();
                
                // 如果游戏还没开始，显示开始界面
                if (!gameState.gameStarted) {
                    drawStartScreen();
                    return;
                }

                // 绘制固定平台
                for (const platform of gameState.staticPlatforms) {
                    // 检查是否是最近踩踏的平台
                    const isRecentlySteppedOn = gameState.player.lastSteppedPlatforms.some(
                        p => p.x === platform.x && p.y === platform.y
                    );
                    
                    // 绘制平台主体
                    ctx.fillStyle = platform.color;
                    ctx.fillRect(
                        platform.x - gameState.camera.x, 
                        platform.y - gameState.camera.y, 
                        platform.width, 
                        platform.height
                    );
                    
                    // 绘制平台上部
                    ctx.fillStyle = isRecentlySteppedOn ? '#8abbdd' : '#6a8aa5';
                    ctx.fillRect(
                        platform.x - gameState.camera.x,
                        platform.y - gameState.camera.y,
                        platform.width,
                        platform.height/3
                    );
                    
                    // 绘制平台边缘高光
                    ctx.fillStyle = isRecentlySteppedOn ? '#aaddff' : '#8aaacc';
                    ctx.fillRect(
                        platform.x - gameState.camera.x, 
                        platform.y - gameState.camera.y, 
                        platform.width, 
                        2
                    );
                    
                    // 如果是最近踩踏过的平台，绘制特殊指示
                    if (isRecentlySteppedOn) {
                        // 绘制小的光晕效果
                        const glow = ctx.createRadialGradient(
                            platform.x + platform.width/2 - gameState.camera.x,
                            platform.y - gameState.camera.y,
                            0,
                            platform.x + platform.width/2 - gameState.camera.x,
                            platform.y - gameState.camera.y,
                            platform.width/2
                        );
                        glow.addColorStop(0, 'rgba(170, 220, 255, 0.3)');
                        glow.addColorStop(1, 'rgba(170, 220, 255, 0)');
                        
                        ctx.fillStyle = glow;
                        ctx.beginPath();
                        ctx.arc(
                            platform.x + platform.width/2 - gameState.camera.x,
                            platform.y - gameState.camera.y,
                            platform.width/2,
                            0, Math.PI, true
                        );
                        ctx.fill();
                    }
                    
                    // 绘制平台底部阴影
                    ctx.fillStyle = '#3a5a75';
                    ctx.fillRect(
                        platform.x - gameState.camera.x,
                        platform.y + platform.height - 3 - gameState.camera.y,
                        platform.width,
                        3
                    );
                }
                
                // 绘制尖刺
                drawSpikes();
                
                // 检查终点平台是否被踩踏过
                const isEndPlatformStepped = gameState.player.lastSteppedPlatforms.some(
                    p => p.x === gameState.endPlatform.x && p.y === gameState.endPlatform.y
                );
                
                // 绘制终点平台
                const endPlatform = gameState.endPlatform;
                
                // 绘制海底风格的终点平台
                if (endPlatform.isSeaStyle) {
                    const x = endPlatform.x - gameState.camera.x;
                    const y = endPlatform.y - gameState.camera.y;
                    const width = endPlatform.width;
                    const height = endPlatform.height;
                    
                    // 绘制平台基础部分（珊瑚礁样式）
                    // 平台底部 - 深蓝绿色
                    ctx.fillStyle = '#1a6281';
                    ctx.fillRect(x, y, width, height);
                    
                    // 平台顶部 - 浅绿松石色
                    ctx.fillStyle = '#40E0D0';
                    ctx.fillRect(x, y, width, height * 0.4);
                    
                    
                    // 添加小气泡装饰
                    for (let i = 0; i < 5; i++) {
                        const bubbleX = x + Math.random() * width;
                        const bubbleY = y - 5 - Math.random() * 15;
                        const bubbleSize = 2 + Math.random() * 4;
                        
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.arc(bubbleX, bubbleY, bubbleSize, 0, Math.PI * 2);
                        ctx.stroke();
                        
                        // 气泡高光
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                        ctx.beginPath();
                        ctx.arc(bubbleX - bubbleSize * 0.3, bubbleY - bubbleSize * 0.3, bubbleSize * 0.4, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                   
                } else {
                    // 使用原来的样式绘制
                    ctx.fillStyle = endPlatform.color;
                    ctx.fillRect(
                        endPlatform.x - gameState.camera.x, 
                        endPlatform.y - gameState.camera.y, 
                        endPlatform.width, 
                        endPlatform.height
                    );
                }

                // 绘制气泡平台
                for (const platform of gameState.platforms) {
                    drawPlatform(platform);
                }
                
                // 绘制宝箱精灵图，替换旗帜
                const chest = gameState.chest;
                if (chest.sprite && chest.sprite.complete && !chest.useDrawnChest) {
                    // 确定当前帧
                    let frameIndex = chest.currentFrame;
                    
                    // 如果没有动画和开启，保持在前三帧之一（闭合状态）
                    if (!chest.isAnimating && !chest.isOpened) {
                        frameIndex = Math.floor(gameState.frameCount / 30) % 3; // 循环显示前三帧作为闭合时的微动画
                    }
                    
                    try {
                        // 绘制宝箱精灵图的当前帧
                        ctx.drawImage(
                            chest.sprite,
                            frameIndex * chest.frameWidth,  // 源X（当前帧的X位置）
                            0,                              // 源Y（精灵图只有一行）
                            chest.frameWidth,               // 源宽度
                            chest.frameHeight,              // 源高度
                            chest.x - gameState.camera.x,   // 目标X
                            chest.y - gameState.camera.y,   // 目标Y
                            chest.width,                    // 目标宽度
                            chest.height                    // 目标高度
                        );
                    } catch (error) {
                        console.error("绘制宝箱出错:", error);
                        // 出错时切换到绘制模式
                        chest.useDrawnChest = true;
                        drawCustomChest(chest);
                    }
                } else {
                    // 使用自定义绘制的宝箱
                    drawCustomChest(chest);
                }
                
                // 渲染宝箱闪光效果 - 在粒子效果之前渲染
                renderChestGlowEffects();
                
                // 绘制星星收集物
                drawMedals();
                
                // 绘制茶收集物
                drawTeas();
                
                // 绘制玩家
                drawPlayer();
                
                // 在玩家绘制后，绘制茶特效
                if (gameState.player.teaEffect.active) {
                    drawTeaEffect(gameState.player);
                }
                
                // 绘制粒子效果
                drawParticles();
                
                // 显示收集计数
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 20px Arial';
                ctx.textAlign = 'left';
                ctx.fillText(`金牌: ${gameState.player.collected}/${gameState.stars.length}`, 30, 40);
                
                // 显示GM提示，如果存在
                if (gameState.gmMessage) {
                    renderGMMessage();
                }
                
                
                // 如果游戏结束，显示游戏结束画面
                if (gameState.gameOver) {
                    drawGameOver();
                } else if (gameState.victory) {
                    // 如果胜利，显示胜利画面
                    drawVictory();
                }
                
                // 在渲染函数中添加初始气泡的绘制
                if (gameState.startBubble && !gameState.startBubble.isPopping) {
                    const bubble = gameState.startBubble;
                    const x = bubble.x - gameState.camera.x;
                    const y = bubble.y - gameState.camera.y;
                    
                    // 应用摇摆效果
                    const wobbleX = Math.sin(gameState.frameCount * bubble.wobble.speed) * bubble.wobble.amount;
                    
                    ctx.save();
                    
                    const radius = Math.min(bubble.width, bubble.height) / 2 * bubble.scale;
                    
                    // 绘制气泡内部填充
                    const fillGradient = ctx.createRadialGradient(
                        x + bubble.width/2 + wobbleX, y + bubble.height/2, 0,
                        x + bubble.width/2 + wobbleX, y + bubble.height/2, radius
                    );
                    fillGradient.addColorStop(0, `rgba(250, 253, 255, ${bubble.opacity * 0.3})`);
                    fillGradient.addColorStop(0.6, `rgba(235, 245, 255, ${bubble.opacity * 0.2})`);
                    fillGradient.addColorStop(1, `rgba(220, 240, 255, ${bubble.opacity * 0.1})`);
                    
                    ctx.beginPath();
                    ctx.arc(
                        x + bubble.width/2 + wobbleX,
                        y + bubble.height/2,
                        radius,
                        0, Math.PI * 2
                    );
                    ctx.fillStyle = fillGradient;
                    ctx.fill();
                    
                    // 绘制气泡边缘
                    ctx.beginPath();
                    ctx.arc(
                        x + bubble.width/2 + wobbleX,
                        y + bubble.height/2,
                        radius,
                        0, Math.PI * 2
                    );
                    ctx.strokeStyle = `rgba(255, 255, 255, ${bubble.opacity * 0.9})`;
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    // 绘制气泡高光
                    const highlightGradient = ctx.createRadialGradient(
                        x + bubble.width/2 - radius * 0.3 + wobbleX,
                        y + bubble.height/2 - radius * 0.3,
                        0,
                        x + bubble.width/2 - radius * 0.3 + wobbleX,
                        y + bubble.height/2 - radius * 0.3,
                        radius * 0.4
                    );
                    highlightGradient.addColorStop(0, `rgba(255, 255, 255, ${bubble.opacity * 0.7})`);
                    highlightGradient.addColorStop(1, `rgba(255, 255, 255, 0)`);
                    
                    ctx.beginPath();
                    ctx.arc(
                        x + bubble.width/2 - radius * 0.3 + wobbleX,
                        y + bubble.height/2 - radius * 0.3,
                        radius * 0.4,
                        0, Math.PI * 2
                    );
                    ctx.fillStyle = highlightGradient;
                    ctx.fill();
                    
                    ctx.restore();
                }
                
                // 在所有内容之上绘制调试信息
                drawDebugInfo();
            }

            // 创建海底场景元素
            function createPirateScene() {
                gameState.pirateElements = [];
                
                // 添加深海光束 - 增强氛围感
                for (let i = 0; i < 8; i++) {
                    gameState.pirateElements.push({
                        type: 'oceanRay',
                        x: Math.random() * canvas.width,
                        y: 0,
                        width: 80 + Math.random() * 100,
                        height: canvas.height,
                        opacity: 0.05 + Math.random() * 0.08,
                        parallaxSpeed: 0.3 + Math.random() * 0.2  // 添加视差速度
                    });
                }
                // 创建星星收集物
                createMedals();
                
                // 创建茶收集物
                createTeas();
                
                // 添加海草和珊瑚
                for (let i = 0; i < 15; i++) {
                    gameState.pirateElements.push({
                        type: 'seaweed',
                        x: Math.random() * canvas.width * 2, // 分布在更大范围
                        y: canvas.height - 30,
                        height: 40 + Math.random() * 50,
                        width: 15 + Math.random() * 10,
                        segments: 3 + Math.floor(Math.random() * 3),
                        swaySpeed: 0.01 + Math.random() * 0.02,
                        swayAmount: 3 + Math.random() * 8,
                        phase: Math.random() * Math.PI * 2,
                        color: Math.random() > 0.7 ? '#5d936a' : '#3a7e68',
                        parallaxSpeed: 0.5 + Math.random() * 0.2  // 添加视差速度
                    });
                }
                
                // 添加气泡
                for (let i = 0; i < 35; i++) {  // 增加气泡数量
                    gameState.pirateElements.push({
                        type: 'bubble',
                        x: Math.random() * canvas.width * 3.5 + gameState.camera.x, // 分布在更大范围且跟随相机
                        y: canvas.height - Math.random() * 150, // 分布在更大的垂直范围
                        size: 2 + Math.random() * 8, // 更多的尺寸变化
                        speed: 0.5 + Math.random() * 1.8, // 更多的速度变化
                        wobble: 0.5 + Math.random() * 1.2, // 更多的摇摆变化
                        phase: Math.random() * Math.PI * 2,
                        parallaxSpeed: 0.3 + Math.random() * 0.5  // 不同的视差速度，使气泡看起来有层次感
                    });
                }
                
                // 添加鱼群
                for (let i = 0; i < 5; i++) {
                    const fishCount = 3 + Math.floor(Math.random() * 5);
                    const direction = Math.random() > 0.5 ? 1 : -1;
                    
                    gameState.pirateElements.push({
                        type: 'fishSchool',
                        x: direction > 0 ? -50 : canvas.width + 50,
                        y: 100 + Math.random() * (canvas.height - 200),
                        direction: direction,
                        speed: 0.3 + Math.random() * 0.8,
                        parallaxSpeed: 0.7 + Math.random() * 0.3,  // 添加视差速度
                        fish: Array.from({length: fishCount}, () => ({
                            offsetX: (Math.random() - 0.5) * 60,
                            offsetY: (Math.random() - 0.5) * 30,
                            size: 8 + Math.random() * 7,
                            tailPhase: Math.random() * Math.PI * 2
                        }))
                    });
                }
                
                // 添加主潜艇 - 位置调整为底部中央
                gameState.pirateElements.push({
                    type: 'submarine',
                    x: canvas.width * 0.45,  // 稍微左移，为小潜艇腾出空间
                    y: canvas.height - 80,
                    width: 200,
                    height: 80,
                    bobAmount: 1.5,
                    bobSpeed: 0.01,
                    parallaxSpeed: 0.02,
                    windows: [
                        { x: -70, y: 25, radius: 8, glow: 0.8 + Math.random() * 0.2 },
                        { x: -35, y: 25, radius: 8, glow: 0.8 + Math.random() * 0.2 },
                        { x: 0, y: 25, radius: 8, glow: 0.8 + Math.random() * 0.2 },
                        { x: 35, y: 25, radius: 8, glow: 0.8 + Math.random() * 0.2 },
                        { x: 70, y: 25, radius: 8, glow: 0.8 + Math.random() * 0.2 }
                    ]
                });
                
                // 添加小潜艇 - 紧贴主潜艇右侧
                gameState.pirateElements.push({
                    type: 'smallSubmarine',
                    x: canvas.width * 0.45 + 200,  // 主潜艇右侧30像素
                    y: canvas.height - 70,         // 稍微上移以错开高度
                    width: 90,
                    height: 40,
                    bobAmount: 1,
                    bobSpeed: 0.017,               // 稍微不同的频率创造错落感
                    parallaxSpeed: 0.02            // 与主潜艇相同的视差速度
                });
                
                // 放置轻雾层次
                for (let i = 0; i < 4; i++) {
                    gameState.pirateElements.push({
                        type: 'mist',
                        y: canvas.height - 30 - i * 70,
                        opacity: 0.04 + i * 0.02,
                        speed: 0.1 + i * 0.05,
                        parallaxSpeed: 0.1 + i * 0.1
                    });
                }
            }

            // 绘制海底场景
            function drawPirateScene() {
                // 更新帧计数
                gameState.frameCount++;
                
                // 绘制海底渐变背景
                const skyGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                skyGradient.addColorStop(0, '#071526');  // 深蓝色顶部
                skyGradient.addColorStop(0.4, '#0c2440'); // 中深蓝
                skyGradient.addColorStop(0.7, '#0e3757'); // 中蓝绿
                skyGradient.addColorStop(1, '#0d4a6e');   // 底部更亮蓝绿
                ctx.fillStyle = skyGradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // 调整背景元素，确保在任何相机位置都能看到环境元素
                const cameraX = gameState.camera.x;
                
                // 绘制光束 - 创造深海神秘氛围，确保在整个关卡中都有光束
                for (const element of gameState.pirateElements) {
                    if (element.type === 'oceanRay') {
                        // 修改光束渲染逻辑，确保无论相机在哪里都能看到光束
                        const parallaxX = (element.x + cameraX * 0.1) % (canvas.width * 2);
                        const drawX = parallaxX - canvas.width;
                        
                        const gradient = ctx.createLinearGradient(
                            drawX, 0, 
                            drawX, canvas.height
                        );
                        gradient.addColorStop(0, `rgba(120, 180, 210, ${element.opacity})`);
                        gradient.addColorStop(1, 'rgba(120, 180, 210, 0)');
                        
                        ctx.fillStyle = gradient;
                        ctx.beginPath();
                        ctx.moveTo(drawX, 0);
                        ctx.lineTo(drawX - element.width/2, canvas.height);
                        ctx.lineTo(drawX + element.width/2, canvas.height);
                        ctx.closePath();
                        ctx.fill();
                    }
                }

                // 绘制海草 - 让它们跟随相机移动，始终在视野内
                for (const element of gameState.pirateElements) {
                    if (element.type === 'seaweed') {
                        // 修改海草渲染逻辑，使海草均匀分布在视野中
                        const parallaxX = (element.x + cameraX * 0.3) % (canvas.width * 2);
                        const drawX = parallaxX - canvas.width;
                        
                        // 摇摆动画
                        element.phase += element.swaySpeed;
                        const sway = Math.sin(element.phase) * element.swayAmount;
                        
                        // 绘制弯曲的海草
                        ctx.fillStyle = element.color;
                        ctx.beginPath();
                        ctx.moveTo(drawX, element.y);
                        
                        // 用贝塞尔曲线创建自然弯曲
                        ctx.bezierCurveTo(
                            drawX + sway, element.y - element.height * 0.4,
                            drawX + sway * 1.5, element.y - element.height * 0.7,
                            drawX + sway * 0.8, element.y - element.height
                        );
                        
                        ctx.bezierCurveTo(
                            drawX + sway * 1.2, element.y - element.height * 0.7,
                            drawX + sway * 0.6, element.y - element.height * 0.4,
                            drawX + element.width, element.y
                        );
                        
                        ctx.closePath();
                        ctx.fill();
                    }
                }
                
                // 绘制气泡，确保在任何位置都有气泡效果
                for (const element of gameState.pirateElements) {
                    if (element.type === 'bubble') {
                        // 修改气泡渲染逻辑，根据玩家位置调整视差效果
                        // 确保气泡始终可见，但同时保持自己的运动轨迹
                        const bubbleParallaxFactor = element.parallaxSpeed || 0.4;
                        
                        // 气泡的绝对坐标位置（保持自身运动轨迹）
                        element.y -= element.speed;
                        element.x += Math.sin(element.phase) * element.wobble * 0.2;
                        element.phase += 0.03;
                        
                        // 计算显示位置（与相机位置相关）
                        // 使用除法而不是乘法，这样气泡会随着玩家移动而移动，但移动速度比玩家慢
                        const parallaxX = element.x - (gameState.camera.x * bubbleParallaxFactor);
                        
                        // 重置离开屏幕的气泡，但保持在玩家的可见范围内
                        if (element.y < -20) {
                            element.y = canvas.height + Math.random() * 20;
                            // 根据当前相机位置重新生成气泡的x坐标，确保在玩家视野范围内
                            element.x = gameState.camera.x + (Math.random() * canvas.width * 1.5);
                        }
                        
                        // 仅渲染在或接近屏幕上的气泡，以提高性能
                        if (parallaxX > -50 && parallaxX < canvas.width + 50) {
                            // 绘制气泡
                            ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
                            ctx.lineWidth = 0.8;
                            ctx.beginPath();
                            ctx.arc(parallaxX, element.y, element.size, 0, Math.PI * 2);
                            ctx.stroke();
                            
                            // 气泡内部渐变
                            const gradient = ctx.createRadialGradient(
                                parallaxX - element.size/3, element.y - element.size/3, 0,
                                parallaxX, element.y, element.size
                            );
                            gradient.addColorStop(0, 'rgba(255, 255, 255, 0.2)');
                            gradient.addColorStop(1, 'rgba(255, 255, 255, 0.05)');
                            
                            ctx.fillStyle = gradient;
                            ctx.fill();
                            
                            // 气泡高光点
                            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                            ctx.beginPath();
                            ctx.arc(parallaxX - element.size/3, element.y - element.size/3, element.size/6, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                }
                
                // 绘制鱼群
                for (const element of gameState.pirateElements) {
                    if (element.type === 'fishSchool') {
                        // 更新鱼群移动
                        element.x += element.speed * element.direction;
                        
                        // 计算视觉上的绘制位置（考虑相机位置和视差效果）
                        const parallaxFactor = 0.7; // 视差因子，使鱼群移动比相机慢
                        const effectiveCameraX = cameraX * parallaxFactor;
                        let drawX = element.x - effectiveCameraX;
                        
                        // 当鱼群移出视野很远时，将其重置到另一侧
                        const resetDistance = canvas.width * 2;
                        if (element.direction > 0 && drawX > resetDistance) {
                            element.x = effectiveCameraX - canvas.width;
                            drawX = element.x - effectiveCameraX;
                        } else if (element.direction < 0 && drawX < -resetDistance) {
                            element.x = effectiveCameraX + canvas.width;
                            drawX = element.x - effectiveCameraX;
                        }
                        
                        // 只在画面附近才绘制，以优化性能
                        if (drawX > -200 && drawX < canvas.width + 200) {
                            // 绘制每条鱼
                            for (const fish of element.fish) {
                                // 更新鱼尾摆动
                                fish.tailPhase += 0.1;
                                const tailWag = Math.sin(fish.tailPhase) * fish.size/2;
                                
                                const fishX = drawX + fish.offsetX;
                                const fishY = element.y + fish.offsetY;
                                
                                // 鱼身体
                                ctx.fillStyle = 'rgba(150, 180, 200, 0.8)';
                ctx.beginPath();
                                ctx.ellipse(fishX, fishY, fish.size, fish.size/2, 0, 0, Math.PI * 2);
                                ctx.fill();
                                
                                // 鱼尾
                                ctx.beginPath();
                                if (element.direction > 0) {
                                    ctx.moveTo(fishX - fish.size, fishY - fish.size/4);
                                    ctx.lineTo(fishX - fish.size*1.5, fishY + tailWag);
                                    ctx.lineTo(fishX - fish.size, fishY + fish.size/4);
                                } else {
                                    ctx.moveTo(fishX + fish.size, fishY - fish.size/4);
                                    ctx.lineTo(fishX + fish.size*1.5, fishY + tailWag);
                                    ctx.lineTo(fishX + fish.size, fishY + fish.size/4);
                                }
                                ctx.fill();
                                
                                // 鱼眼
                                const eyeX = fishX + (element.direction > 0 ? fish.size/2 : -fish.size/2);
                                
                                ctx.fillStyle = 'white';
                                ctx.beginPath();
                                ctx.arc(eyeX, fishY - fish.size/4, fish.size/5, 0, Math.PI * 2);
                                ctx.fill();
                                
                                ctx.fillStyle = 'black';
                                ctx.beginPath();
                                ctx.arc(eyeX, fishY - fish.size/4, fish.size/10, 0, Math.PI * 2);
                                ctx.fill();
                            }
                        }
                    }
                }
                
                // 绘制潜水艇 - 让它们始终跟随玩家，保持在屏幕视野中
                for (const element of gameState.pirateElements) {
                    if (element.type === 'submarine' || element.type === 'smallSubmarine') {
                        const bob = Math.sin(gameState.frameCount * element.bobSpeed) * element.bobAmount;
                        const isSmall = element.type === 'smallSubmarine';
                        
                        // 计算绘制位置 - 保持在视野内，但有轻微跟随效果
                        let drawX;
                        if (isSmall) {
                            // 小潜艇总是跟随主潜艇
                            drawX = canvas.width * 0.7 - gameState.camera.x * 0.05;
                        } else {
                            // 主潜艇跟随玩家，但保持在屏幕中
                                                // 当玩家超过12000米时，调整潜艇位置
                            if (gameState.camera.x > 11000) {
                                // 在12000-17000米范围内，让潜艇保持在画面中央
                                const relativePosition = (gameState.camera.x - 12000) / 5000; // 计算相对位置
                                drawX = canvas.width * (0.3 + relativePosition * 0.4) - gameState.camera.x * 0.05;
                            } else {
                                // 12000米之前保持原有位置
                                drawX = canvas.width * 0.3 - gameState.camera.x * 0.05;
                            }
                        }
                        
                        // 潜艇主体
                        const gradient = ctx.createLinearGradient(0, element.y + bob, 0, element.y + element.height + bob);
                        gradient.addColorStop(0, isSmall ? '#4a6a85' : '#5a7a95');
                        gradient.addColorStop(1, isSmall ? '#2a4a65' : '#3a5a75');
                        
                        ctx.fillStyle = gradient;
                        ctx.beginPath();
                        ctx.ellipse(
                            drawX + element.width/2,
                            element.y + bob,
                            element.width/2,
                            element.height/2,
                            0, 0, Math.PI * 2
                        );
                        ctx.fill();
                        
                        // 潜艇顶部
                        if (!isSmall) {
                            ctx.fillStyle = '#3a5a75';
                            ctx.beginPath();
                            ctx.ellipse(
                                drawX + element.width*0.5,
                                element.y - element.height*0.2 + bob,
                                element.width*0.2,
                                element.height*0.2,
                                0, 0, Math.PI, true
                            );
                            ctx.fill();
                            
                            // 潜望镜
                            ctx.fillStyle = '#2a4a65';
                            ctx.fillRect(
                                drawX + element.width * 0.5 - 3,  // 调整到中央
                                element.y - element.height*0.2 - 30 + bob,
                                6,
                                30
                            );
                            
                            // 潜望镜顶部
                            ctx.fillRect(
                                drawX + element.width * 0.5 - 5,  // 调整到中央
                                element.y - element.height*0.2 - 33 + bob,
                                10,
                                3
                            );
                            
                            // 绘制窗户 - 修正窗户位置
                            if (element.windows) {
                                for (const window of element.windows) {
                                    const windowX = drawX + element.width/2 + window.x;
                                    const windowY = element.y + bob + window.y;
                                    
                                    // 窗户发光效果
                                    const glow = ctx.createRadialGradient(
                                        windowX, windowY, 0,
                                        windowX, windowY, window.radius * 2
                                    );
                                    glow.addColorStop(0, `rgba(162, 220, 240, ${window.glow})`);
                                    glow.addColorStop(1, 'rgba(162, 220, 240, 0)');
                                    
                                    ctx.fillStyle = glow;
                                    ctx.beginPath();
                                    ctx.arc(windowX, windowY, window.radius * 2, 0, Math.PI * 2);
                                    ctx.fill();
                                    
                                    // 窗户本体
                                    ctx.fillStyle = 'rgba(200, 230, 250, 0.8)';
                                    ctx.beginPath();
                                    ctx.arc(windowX, windowY, window.radius, 0, Math.PI * 2);
                                    ctx.fill();
                                    
                                    // 窗户边框
                                    ctx.strokeStyle = '#2a4a65';
                                    ctx.lineWidth = 1.5;
                                    ctx.stroke();
                                }
                            }
                        } else {
                            // 小潜艇窗户
                            const windowX = drawX + element.width * 0.5;  // 居中放置
                            const windowY = element.y + bob;
                            
                            // 小潜艇窗户发光效果
                            const glow = ctx.createRadialGradient(
                                windowX, windowY, 0,
                                windowX, windowY, element.width * 0.3
                            );
                            glow.addColorStop(0, 'rgba(162, 220, 240, 0.8)');
                            glow.addColorStop(1, 'rgba(162, 220, 240, 0)');
                            
                            ctx.fillStyle = glow;
                            ctx.beginPath();
                            ctx.arc(windowX, windowY, element.width * 0.15 * 2, 0, Math.PI * 2);
                            ctx.fill();
                            
                            // 小潜艇窗户本体
                            ctx.fillStyle = 'rgba(200, 230, 250, 0.8)';
                            ctx.beginPath();
                            ctx.arc(windowX, windowY, element.width * 0.15, 0, Math.PI * 2);
                            ctx.fill();
                            
                            ctx.strokeStyle = '#2a4a65';
                            ctx.lineWidth = 1.5;
                            ctx.stroke();
                        }
                    }
                }
                
                // 绘制轻雾层次 - 增强深度感
                for (const element of gameState.pirateElements) {
                    if (element.type === 'mist') {
                        // 绘制半透明浅蓝雾层
                        ctx.fillStyle = `rgba(120, 180, 210, ${element.opacity})`;
                        ctx.fillRect(0, element.y, canvas.width, 70);
                    }
                }

                // 绘制底部尖刺
                drawSeaSpikes();
            }

            // 添加绘制海底尖刺的函数
            function drawSeaSpikes() {
                // 获取尖刺配置
                const spikes = gameState.spikes;
                const cameraX = gameState.camera.x;
                
                // 计算尖刺间距，覆盖可视区域和两侧额外区域，确保移动时始终可见尖刺
                const totalWidth = canvas.width + 2 * canvas.width; // 扩展至视图两侧
                const spikeSpacing = totalWidth / spikes.count;
                
                // 绘制每个尖刺
                for (let i = 0; i < spikes.count; i++) {
                    // 计算尖刺参数 - 修改位置计算方式，与场景移动保持一致
                    const baseX = i * spikeSpacing - cameraX % spikeSpacing;
                    const height = spikes.baseHeight + (Math.sin(i * 0.7) * spikes.heightVariation);
                    const width = spikes.width + (Math.cos(i * 0.5) * spikes.widthVariation);
                    const yPos = spikes.yPosition;
                    
                    // 添加微动画效果
                    const animOffset = Math.sin(gameState.frameCount * spikes.animationSpeed + i * 0.3) * spikes.animationAmount;
                    
                    // 只绘制在可视区域附近的尖刺
                    if (baseX >= -width * 2 && baseX <= canvas.width + width * 2) {
                        // 创建尖刺渐变
                        const gradient = ctx.createLinearGradient(
                            baseX + width / 2, yPos,
                            baseX + width / 2, yPos - height
                        );
                        gradient.addColorStop(0, spikes.baseColor);
                        gradient.addColorStop(1, spikes.tipColor);
                        
                        // 绘制尖刺主体 - 使用三角形
                        ctx.fillStyle = gradient;
                        ctx.beginPath();
                        ctx.moveTo(baseX, yPos);
                        ctx.lineTo(baseX + width / 2, yPos - height + animOffset);
                        ctx.lineTo(baseX + width, yPos);
                ctx.closePath();
                ctx.fill();
                
                        // 添加发光效果 - 弱化发光特效
                        const glowGradient = ctx.createRadialGradient(
                            baseX + width / 2, yPos - height * 0.6 + animOffset,
                            0,
                            baseX + width / 2, yPos - height * 0.6 + animOffset,
                            height * 0.2 // 减小发光半径
                        );
                        glowGradient.addColorStop(0, spikes.glowColor);
                        glowGradient.addColorStop(1, 'rgba(100, 200, 255, 0)');
                        
                        ctx.fillStyle = glowGradient;
                        ctx.beginPath();
                        ctx.arc(
                            baseX + width / 2, 
                            yPos - height * 0.6 + animOffset, 
                            height * 0.2, // 减小发光半径
                            0, Math.PI * 2
                        );
                        ctx.fill();
                        
                        // 如果启用，添加气泡装饰
                        if (spikes.hasBubbles && Math.random() < spikes.bubbleDensity) {
                            // 为每个尖刺添加1-3个气泡
                            const bubbleCount = 1 + Math.floor(Math.random() * 3);
                            for (let j = 0; j < bubbleCount; j++) {
                                const bubbleSize = 1 + Math.random() * 3;
                                const bubbleX = baseX + Math.random() * width;
                                const bubbleY = yPos - Math.random() * height * 0.7;
                                
                                // 绘制气泡
                                ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
                                ctx.lineWidth = 0.5;
                                ctx.beginPath();
                                ctx.arc(bubbleX, bubbleY, bubbleSize, 0, Math.PI * 2);
                                ctx.stroke();
                                
                                // 气泡高光
                                ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                                ctx.beginPath();
                                ctx.arc(
                                    bubbleX - bubbleSize * 0.3, 
                                    bubbleY - bubbleSize * 0.3, 
                                    bubbleSize * 0.4, 
                                    0, Math.PI * 2
                                );
                                ctx.fill();
                            }
                        }
                        
                        // 如果启用，添加藻类装饰
                        if (spikes.hasAlgae && Math.random() < spikes.algaeDensity) {
                            const algaeWidth = 3 + Math.random() * 5;
                            const algaeHeight = 5 + Math.random() * 10;
                            const algaeX = baseX + Math.random() * (width - algaeWidth);
                            
                            // 绘制藻类
                            const algaeColor = Math.random() > 0.5 ? '#1d7a8c' : '#286e5e';
                            ctx.fillStyle = algaeColor;
                            
                            ctx.beginPath();
                            ctx.moveTo(algaeX, yPos);
                            ctx.quadraticCurveTo(
                                algaeX + algaeWidth / 2, 
                                yPos - algaeHeight * 0.7, 
                                algaeX + algaeWidth, 
                                yPos
                            );
                            ctx.fill();
                        }
                    }
                }
            }

            // 绘制星星收集物
            function drawMedals() {
                for (const medal of gameState.stars) {
                    if (medal.collected) continue; // 跳过已收集的金牌
                    
                    // 应用浮动效果
                    const x = medal.x - gameState.camera.x;
                    const y = medal.y + Math.sin(gameState.frameCount * medal.wobble.speed) * medal.wobble.amount - gameState.camera.y;
                    
                    // 金牌绘制
                    ctx.beginPath();
                    ctx.arc(x + medal.width / 2, y + medal.height / 2, medal.width / 2, 0, Math.PI * 2);
                    ctx.fillStyle = palette.gold;
                    ctx.fill();
                    
                    // 金牌上的图案
                    ctx.beginPath();
                    ctx.arc(x + medal.width / 2, y + medal.height / 2, medal.width / 3, 0, Math.PI * 2);
                    ctx.fillStyle = palette.goldShine;
                    ctx.fill();
                    
                    // 金牌的光晕 - 使用正弦波创建呼吸光效
                    const glowSize = 3 + Math.sin(gameState.frameCount * 0.1) * 2;
                    ctx.beginPath();
                    ctx.arc(x + medal.width / 2, y + medal.height / 2, medal.width / 2 + glowSize, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(255, 215, 0, 0.2)';
                    ctx.fill();
                    
                    // 金牌丝带
                    ctx.beginPath();
                    ctx.moveTo(x + medal.width / 2, y);
                    ctx.lineTo(x + medal.width / 2 - 3, y - 5);
                    ctx.lineTo(x + medal.width / 2 + 3, y - 5);
                ctx.closePath();
                    ctx.fillStyle = palette.goldRibbon;
                ctx.fill();
                }
            }

            // 创建收集物粒子效果
            function createMedalParticles(x, y) {
                // 创建金色闪光粒子
                for (let i = 0; i < 20; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 2 + Math.random() * 3;
                    
                    gameState.particles.push({
                        x: x,
                        y: y,
                        radius: Math.random() * 3 + 1,
                        color: Math.random() > 0.5 ? palette.gold : palette.goldShine,
                        velocityX: Math.cos(angle) * speed,
                        velocityY: Math.sin(angle) * speed,
                        life: 30 + Math.random() * 20
                    });
                }
                
                // 添加光线效果
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    const length = 15 + Math.random() * 10;
                    
                    gameState.particles.push({
                        x: x,
                        y: y,
                        radius: 1,
                        color: 'rgba(255, 215, 0, 0.7)',
                        velocityX: Math.cos(angle) * length / 10,
                        velocityY: Math.sin(angle) * length / 10,
                        life: 15,
                        isRay: true,
                        rayLength: length,
                        rayAngle: angle
                    });
                }
                
                // 添加一些小星星
                for (let i = 0; i < 5; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const distance = 5 + Math.random() * 15;
                    
                    gameState.particles.push({
                        x: x + Math.cos(angle) * distance,
                        y: y + Math.sin(angle) * distance,
                        radius: 2,
                        color: 'rgba(255, 255, 255, 0.9)',
                        velocityX: Math.cos(angle) * 0.5,
                        velocityY: Math.sin(angle) * 0.5 - 0.5,
                        life: 20 + Math.random() * 10,
                        isStar: true
                    });
                }
            }

            // 创建茶收集物
            function createTeas() {
                gameState.teas = [];
                gameState.collectedTeas = 0;
                
                // 添加一个初始茶
                const initialTea = {
                    x: 350,  // 起始区域附近
                    y: 180,
                    width: 40,
                    height: 40,
                    collected: false,
                    wobble: {
                        speed: 0.04,
                        amount: 5,
                        phase: Math.random() * Math.PI * 2
                    },
                    steamParticles: []
                };
                
                // 为初始茶添加蒸汽粒子
                for (let i = 0; i < 5; i++) {
                    initialTea.steamParticles.push({
                        offsetX: (Math.random() - 0.5) * 15,
                        offsetY: -5 - Math.random() * 10,
                        size: 3 + Math.random() * 3,
                        speed: 0.2 + Math.random() * 0.3,
                        opacity: 0.6 + Math.random() * 0.4,
                        lifespan: 0
                    });
                }
                
                gameState.teas.push(initialTea);
            }
            
            // 随机位置生成新茶
            function spawnNewTea() {
                // 确保不超过3个茶(1个初始 + 2个刷新)
                if (gameState.teas.length >= 3) return;
                
                // 随机选择生成位置 - 避开起始区域和终点区域，并适应延长的关卡
                const minX = 800;
                const maxX = 13600; // 调整到新的关卡长度
                const teaX = minX + Math.random() * (maxX - minX);
                const teaY = 150 + Math.random() * 250; // 随机高度
                
                const newTea = {
                    x: teaX,
                    y: teaY,
                    width: 40,
                    height: 40,
                    collected: false,
                    wobble: {
                        speed: 0.04,
                        amount: 5,
                        phase: Math.random() * Math.PI * 2
                    },
                    steamParticles: []
                };
                
                // 为新茶添加蒸汽粒子
                for (let i = 0; i < 5; i++) {
                    newTea.steamParticles.push({
                        offsetX: (Math.random() - 0.5) * 15,
                        offsetY: -5 - Math.random() * 10,
                        size: 3 + Math.random() * 3,
                        speed: 0.2 + Math.random() * 0.3,
                        opacity: 0.6 + Math.random() * 0.4,
                        lifespan: 0
                    });
                }
                
                gameState.teas.push(newTea);
            }
            
            // 更新茶收集物
            function updateTeas() {
                // 更新茶的刷新计时器
                gameState.teaSpawnTimer += 16.67; // 约60fps下的一帧时间
                
                // 检查是否需要生成新茶
                if (gameState.teaSpawnTimer >= gameState.teaSpawnInterval) {
                    gameState.teaSpawnTimer = 0;
                    spawnNewTea();
                }
                
                // 更新每个茶的动画和蒸汽效果
                for (const tea of gameState.teas) {
                    if (tea.collected) continue;
                    
                    // 更新蒸汽粒子
                    for (const particle of tea.steamParticles) {
                        particle.lifespan += 0.02;
                        if (particle.lifespan > 1) {
                            // 重置粒子
                            particle.lifespan = 0;
                            particle.offsetY = -5 - Math.random() * 5;
                            particle.opacity = 0.7 + Math.random() * 0.3;
                        }
                        // 上升并消散
                        particle.offsetY -= particle.speed;
                        particle.opacity -= 0.01;
                    }
                }
            }

            // 检查茶碰撞
            function checkTeaCollision() {
                for (let i = 0; i < gameState.teas.length; i++) {
                    const tea = gameState.teas[i];
                    if (!tea.collected &&
                        gameState.player.x + gameState.player.width > tea.x &&
                        gameState.player.x < tea.x + tea.width &&
                        gameState.player.y + gameState.player.height > tea.y &&
                        gameState.player.y < tea.y + tea.height) {
                        
                        tea.collected = true;
                        gameState.collectedTeas++;
                        createTeaParticles(tea.x + tea.width/2, tea.y + tea.height/2);
                    }
                }
            }

            // 茶收集粒子效果
            function createTeaParticles(x, y) {
                // 创建漂浮文字粒子("茶")
                for (let i = 0; i < 10; i++) {
                    const angle = (Math.random() * Math.PI) - Math.PI/2; // 主要向上发散
                    const speed = 1 + Math.random() * 2;
                    
                    gameState.particles.push({
                        x: x,
                        y: y,
                        radius: 3 + Math.random() * 2,
                        color: 'rgba(90, 58, 40, 0.8)',
                        velocityX: Math.cos(angle) * speed,
                        velocityY: Math.sin(angle) * speed - 2, // 向上偏移
                        life: 30 + Math.random() * 20,
                        isTea: true  // 标记为茶粒子
                    });
                }
                
                // 添加蒸汽粒子
                for (let i = 0; i < 15; i++) {
                    const angle = (Math.random() * Math.PI) - Math.PI/2; // 主要向上发散
                    const speed = 0.5 + Math.random() * 1;
                    
                    gameState.particles.push({
                        x: x,
                        y: y,
                        radius: 4 + Math.random() * 3,
                        color: palette.teaSteam,
                        velocityX: Math.cos(angle) * speed,
                        velocityY: Math.sin(angle) * speed - 1, // 上升
                        life: 40 + Math.random() * 20
                    });
                }
                
                // 添加光效
                for (let i = 0; i < 6; i++) {
                    const angle = (i / 6) * Math.PI * 2;
                    
                    gameState.particles.push({
                        x: x,
                        y: y,
                        radius: 1,
                        color: 'rgba(255, 240, 200, 0.7)',
                        velocityX: Math.cos(angle) * 1.5,
                        velocityY: Math.sin(angle) * 1.5,
                        life: 20,
                        isRay: true,
                        rayLength: 10 + Math.random() * 5,
                        rayAngle: angle
                    });
                }
            }

            // 初始化海底场景
            createPirateScene();

            // 游戏循环
            function gameLoop(timestamp) {
                // 更新时间系统
                if (!gameState.time) {
                    // 确保time对象存在
                    gameState.time = {
                        last: timestamp,
                        now: timestamp,
                        elapsed: 0,
                        delta: 0,
                        timeScale: 1
                    };
                } else if (!gameState.time.last) {
                    gameState.time.last = timestamp;
                }
                
                gameState.time.now = timestamp;
                gameState.time.delta = timestamp - gameState.time.last;
                gameState.time.elapsed = gameState.time.delta / 1000; // 转换为秒
                gameState.time.last = timestamp;
                
                // 防止时间步长过大（例如标签页切换后返回）
                if (gameState.time.elapsed > 0.1) {
                    gameState.time.elapsed = 0.1;
                }
                
                update();
                render();
                requestAnimationFrame(gameLoop);
            }

            // 开始游戏循环
            requestAnimationFrame(gameLoop);

            // 绘制茶收集物
            function drawTeas() {
                for (const tea of gameState.teas) {
                    if (tea.collected) continue; // 跳过已收集的茶
                    
                    // 应用浮动效果
                    const wobbleY = Math.sin(gameState.frameCount * tea.wobble.speed) * tea.wobble.amount;
                    const x = tea.x - gameState.camera.x;
                    const y = tea.y + wobbleY - gameState.camera.y;
                    
                    // 绘制茶杯
                    ctx.fillStyle = palette.teaColor;
                    
                    // 绘制茶表情符
                    ctx.font = '30px Arial';
                    ctx.fillText('🍵', x, y + 22);
                    
                    // 绘制茶蒸汽
                    for (const particle of tea.steamParticles) {
                        if (particle.opacity <= 0) continue;
                        
                        const steamX = x + 20 + particle.offsetX;
                        const steamY = y - 10 + particle.offsetY;
                        
                        ctx.fillStyle = `rgba(200, 240, 255, ${particle.opacity * (1 - particle.lifespan)})`;
                        ctx.beginPath();
                        ctx.arc(steamX, steamY, particle.size, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
                
                // 显示收集数量和功能说明
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 20px Arial';
                ctx.textAlign = 'left';
                ctx.fillText(`茶: ${gameState.collectedTeas}`, 30, 70);
                
                // 添加茶道具功能提示
                if (gameState.collectedTeas > 0) {
                    ctx.font = '14px Arial';
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                    ctx.fillText('(失误时自动消耗一杯茶，在最近平台重新开始)', 100, 70);
                }
            }

            // 找到最近的固定平台
            function findNearestStaticPlatform(playerX) {
                // 初始化最近平台为空和最短距离为无穷大
                let nearestPlatform = null;
                let minDistance = Infinity;
                
                // 遍历所有固定平台
                for (const platform of gameState.staticPlatforms) {
                    // 计算玩家与平台中心的水平距离
                    const platformCenterX = platform.x + platform.width / 2;
                    const distance = Math.abs(playerX - platformCenterX);
                    
                    // 更新最近平台
                    if (distance < minDistance) {
                        minDistance = distance;
                        nearestPlatform = platform;
                    }
                }
                
                // 如果终点平台也是固定平台，也考虑它
                const endPlatform = gameState.endPlatform;
                const endPlatformCenterX = endPlatform.x + endPlatform.width / 2;
                const endPlatformDistance = Math.abs(playerX - endPlatformCenterX);
                
                if (endPlatformDistance < minDistance) {
                    minDistance = endPlatformDistance;
                    nearestPlatform = endPlatform;
                }
                
                return nearestPlatform;
            }
            
            // 创建复活特效
            function createRespawnEffect(x, y) {
                // 创建茶杯符号上升粒子
                for (let i = 0; i < 5; i++) {
                    gameState.particles.push({
                        x: x + (Math.random() - 0.5) * 20,
                        y: y + (Math.random() - 0.5) * 10,
                        radius: 3,
                        color: 'rgba(90, 58, 40, 0.7)',
                        velocityX: 0,
                        velocityY: -1 - Math.random(),
                        life: 40 + Math.random() * 20,
                        isTea: true
                    });
                }
                
                // 添加中心光晕
                for (let i = 0; i < 1; i++) {
                    gameState.particles.push({
                        x: x,
                        y: y,
                        radius: 30,
                        color: 'rgba(255, 255, 255, 0.6)',
                        velocityX: 0,
                        velocityY: 0,
                        life: 30,
                        isGlow: true
                    });
                }
                
                // 添加扩散环
                for (let i = 0; i < 3; i++) {
                    gameState.particles.push({
                        x: x,
                        y: y,
                        radius: 10 + i * 15,
                        color: 'rgba(200, 240, 255, 0.7)',
                        velocityX: 0,
                        velocityY: 0,
                        life: 30 - i * 5,
                        isRing: true,
                        expansionRate: 2 + i * 0.5
                    });
                }
                
                // 添加上升的蒸汽粒子
                for (let i = 0; i < 20; i++) {
                    const angle = Math.PI + (Math.random() - 0.5) * Math.PI;
                    const speed = 0.5 + Math.random() * 1.5;
                    
                    gameState.particles.push({
                        x: x,
                        y: y,
                        radius: 2 + Math.random() * 3,
                        color: 'rgba(200, 240, 255, 0.6)',
                        velocityX: Math.cos(angle) * speed,
                        velocityY: Math.sin(angle) * speed,
                        life: 30 + Math.random() * 20
                    });
                }
            }

            // 创建掉落效果
            function createFallEffect(x, y) {
                // 添加水花效果
                for (let i = 0; i < 30; i++) {
                    const angle = -Math.PI/2 + (Math.random() - 0.5) * Math.PI;
                    const speed = 2 + Math.random() * 4;
                    
                    gameState.particles.push({
                        x: x,
                        y: y,
                        radius: 1 + Math.random() * 3,
                        color: 'rgba(200, 240, 255, 0.7)',
                        velocityX: Math.cos(angle) * speed,
                        velocityY: Math.sin(angle) * speed,
                        life: 20 + Math.random() * 20
                    });
                }
                
                // 添加水波纹效果
                for (let i = 0; i < 3; i++) {
                    gameState.particles.push({
                        x: x,
                        y: y,
                        radius: 5 + i * 10,
                        color: 'rgba(200, 240, 255, 0.5)',
                        velocityX: 0,
                        velocityY: 0,
                        life: 30 - i * 5,
                        isRing: true,
                        expansionRate: 1.5 + i * 0.5
                    });
                }
            }

            // 完全重写茶特效，使用最简单的方法，消除卡顿
            function activateTeaEffect(player) {
                player.teaEffect.active = true;
                player.teaEffect.duration = 0; // 重置为0，从开始计时
                
                try {
                    // 先创建茶特效粒子
                    createTeaEffect(player.x + player.width/2, player.y + player.height/2);
                    
                    // 然后异步播放茶效果音效
                    setTimeout(() => {
                        playSound('teaEffect');
                    }, 0);
                } catch (error) {
                    console.error("激活茶特效时出错:", error);
                    // 即使特效创建失败，也保持茶特效状态激活
                }
            }

            // 添加缺失的茶特效创建函数
            function createTeaEffect(x, y) {
                // 初始化茶特效粒子
                gameState.player.teaEffect.particles = [];
                
                // 添加中心光晕
                gameState.player.teaEffect.particles.push({
                    type: "glow",
                    radius: 40,
                    opacity: 0.8,
                    fadeSpeed: 0.005
                });
                
                // 添加扩散环
                gameState.player.teaEffect.particles.push({
                    type: "ring",
                    radius: 5,
                    maxRadius: 80,
                    speed: 2,
                    opacity: 0.7,
                    width: 3
                });
                
                // 添加扩散粒子
                for (let i = 0; i < 20; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    gameState.player.teaEffect.particles.push({
                        type: "particle",
                        angle: angle,
                        distance: 0,
                        maxDistance: 70 + Math.random() * 30,
                        speed: 0.8 + Math.random() * 0.6,
                        size: 2 + Math.random() * 2,
                        opacity: 0.7 + Math.random() * 0.3
                    });
                }
                
                // 添加一些额外粒子到游戏的粒子系统中
                for (let i = 0; i < 15; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 1 + Math.random() * 2;
                    
                    gameState.particles.push({
                        x: x,
                        y: y,
                        radius: 2 + Math.random() * 2,
                        color: 'rgba(100, 230, 120, 0.7)',
                        velocityX: Math.cos(angle) * speed,
                        velocityY: Math.sin(angle) * speed,
                        life: 30 + Math.random() * 20
                    });
                }
            }

            // 更新茶特效 - 极简版本
            function updateTeaEffect(player) {
                if (!player.teaEffect.active) return;
                
                // 更新持续时间 - 基于实际时间
                player.teaEffect.duration += 60 * gameState.time.elapsed;
                
                // 如果特效持续时间结束，则结束特效
                if (player.teaEffect.duration >= player.teaEffect.maxDuration) {
                    player.teaEffect.active = false;
                    player.teaEffect.particles = []; // 清空粒子
                    return;
                }
                
                // 基于时间更新粒子
                for (let i = 0; i < player.teaEffect.particles.length; i++) {
                    const particle = player.teaEffect.particles[i];
                    
                    if (particle.type === "glow") {
                        // 中心光晕淡出 - 基于时间
                        particle.opacity -= particle.fadeSpeed * 60 * gameState.time.elapsed;
                        if (particle.opacity < 0) particle.opacity = 0;
                    }
                    else if (particle.type === "ring") {
                        // 环形扩散 - 基于时间
                        particle.radius += particle.speed * 60 * gameState.time.elapsed;
                        // 使用幂运算实现时间相关的平滑淡出
                        particle.opacity *= Math.pow(0.97, 60 * gameState.time.elapsed);
                        
                        // 如果环已经扩散到最大半径的80%，创建新环
                        if (particle.radius > particle.maxRadius * 0.8 && player.teaEffect.duration < player.teaEffect.maxDuration * 0.7) {
                            // 每隔一段时间只添加一个新环
                            if (player.teaEffect.particles.filter(p => p.type === "ring").length < 3) {
                                player.teaEffect.particles.push({
                                    type: "ring",
                                    radius: 0,
                                    maxRadius: 80 + Math.random() * 20,
                                    speed: 1.8 + Math.random() * 0.4,
                                    opacity: 0.6,
                                    width: 2
                                });
                            }
                        }
                    }
                    else if (particle.type === "particle") {
                        // 扩散粒子 - 基于时间
                        particle.distance += particle.speed * 60 * gameState.time.elapsed;
                        
                        // 淡出效果 - 基于时间的平滑淡出
                        if (particle.distance > particle.maxDistance * 0.7) {
                            particle.opacity *= Math.pow(0.95, 60 * gameState.time.elapsed);
                        }
                    }
                }
                
                // 删除不可见的粒子
                player.teaEffect.particles = player.teaEffect.particles.filter(p => 
                    !(p.type === "ring" && (p.radius > p.maxRadius || p.opacity < 0.05)) && 
                    !(p.type === "particle" && (p.distance > p.maxDistance || p.opacity < 0.05))
                );
            }

            // 绘制茶特效 - 极简版本
            function drawTeaEffect(player) {
                if (!player.teaEffect.active) return;
                
                const playerCenterX = player.x + player.width / 2 - gameState.camera.x;
                const playerCenterY = player.y + player.height / 2 - gameState.camera.y;
                
                // 不使用复杂的渲染技术，使用最简单的方式绘制
                for (const particle of player.teaEffect.particles) {
                    if (particle.type === "glow") {
                        // 简单光晕
                        ctx.fillStyle = `rgba(100, 230, 120, ${particle.opacity})`;
                        ctx.beginPath();
                        ctx.arc(playerCenterX, playerCenterY, particle.radius, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    else if (particle.type === "ring") {
                        // 简单环
                        ctx.strokeStyle = `rgba(100, 230, 120, ${particle.opacity})`;
                        ctx.lineWidth = particle.width;
                        ctx.beginPath();
                        ctx.arc(playerCenterX, playerCenterY, particle.radius, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                    else if (particle.type === "particle") {
                        // 简单粒子
                        const particleX = playerCenterX + Math.cos(particle.angle) * particle.distance;
                        const particleY = playerCenterY + Math.sin(particle.angle) * particle.distance;
                        
                        ctx.fillStyle = `rgba(100, 230, 120, ${particle.opacity})`;
                        ctx.beginPath();
                        ctx.arc(particleX, particleY, particle.size, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }

                // 绘制玩家
            function drawPlayer() {
                const player = gameState.player;
                const playerX = player.x - gameState.camera.x;
                const playerY = player.y - gameState.camera.y;
                
                
                if (player.sprite) {
                    // 保存当前上下文状态
                    ctx.save();
                    
                    // 设置绘制位置
                    ctx.translate(playerX + player.width/2, playerY + player.height/2);
                    
                    // 如果需要翻转图片
                    if (!player.facingRight) {
                        ctx.scale(-1, 1);
                    }
                    
                    // 绘制精灵图片的当前帧
                    ctx.drawImage(
                        player.sprite,
                        player.currentFrame * player.frameWidth,  // 源X
                        player.currentRow * player.frameHeight,   // 源Y
                        player.frameWidth,                        // 源宽度
                        player.frameHeight,                       // 源高度
                        -player.width/2,                          // 目标X
                        -player.height/2,                         // 目标Y
                        player.width,                             // 目标宽度
                        player.height                             // 目标高度
                    );
                    
                    // 恢复上下文状态
                    ctx.restore();
                } else {
                    // 如果图片还没加载完成，使用默认的矩形绘制
                    ctx.fillStyle = player.color || '#ff5a5f';
                    ctx.fillRect(playerX, playerY, player.width, player.height);
                }
            }
            
            // 绘制胜利画面
            function drawVictory() {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 36px Arial';
                ctx.textAlign = 'center';
                
                // 再次检查是否为全收集特殊状态，确保正确识别
                const isFullCollection = gameState.isFullCollection || 
                    (gameState.stars && gameState.stars.length > 0 && 
                     gameState.player.collected === gameState.stars.length);
                
                // 如果是全收集状态，更新游戏状态标志
                if (isFullCollection && !gameState.isFullCollection) {
                    gameState.isFullCollection = true;
                    console.log("胜利画面: 检测到全收集状态");
                }
                
                // 根据是否为全收集特殊状态显示不同标题
                if (gameState.isFullCollection) {
                    ctx.fillStyle = '#FFD700'; // 金色标题
                    ctx.font = 'bold 40px Arial';
                    ctx.fillText('"唯有热爱能够突破一切。"', canvas.width / 2, canvas.height / 2 - 70);
                    
                    ctx.font = 'bold 24px Arial';
                    ctx.fillText('恭喜你收集了全部金牌！', canvas.width / 2, canvas.height / 2 - 30);
                    
                    ctx.fillStyle = '#ffffff';
                } else {
                    // 根据收集的金牌数量，分为不同档位显示不同文字
                    const collectedCount = gameState.player.collected;
                    const totalCount = gameState.stars.length;
                    let victoryMessage = '';
                    
                    // 分档设置不同的文字
                    if (collectedCount < 20) {
                        victoryMessage = "“哥哥们都好强呀！”";
                    } else if (collectedCount >= 20 && collectedCount <= 39) {
                        victoryMessage = "“发现还是得加倍努力才行呢！”";
                    } else if (collectedCount >= 40 && collectedCount <= 59) {
                        victoryMessage = "“跟大哥哥们一起同场竞技~”";
                    } else if (collectedCount >= 60 && collectedCount <= 72) {
                        victoryMessage = "“人家大哥哥是经历过各种世界比赛的~”";
                    } else if (collectedCount >= 73 && collectedCount <= 83) {
                        victoryMessage = "“我说没有天赋有点凡尔赛啊~”";
                    }
                    
                    // 设置文字样式和显示
                    ctx.font = 'bold 30px Arial';
                    // 根据档位设置不同颜色
                    if (collectedCount >= 73) {
                        // 73-83块金牌，接近全收集，使用浅金色
                        ctx.fillStyle = '#FFE866';
                    } else if (collectedCount >= 60) {
                        // 60-72块金牌，使用淡金色
                        ctx.fillStyle = '#FFF2B3';
                    } else if (collectedCount >= 40) {
                        // 40-59块金牌，使用淡蓝色
                        ctx.fillStyle = '#A6D5FA';
                    } else if (collectedCount >= 20) {
                        // 20-39块金牌，使用淡绿色
                        ctx.fillStyle = '#B3E6CC';
                    } else {
                        // 0-19块金牌，使用白色
                        ctx.fillStyle = '#FFFFFF';
                    }
                    
                    ctx.fillText(victoryMessage, canvas.width / 2, canvas.height / 2 - 50);
                    ctx.fillStyle = '#ffffff'; // 恢复白色
                }
                
                // 显示金牌统计
                ctx.font = '24px Arial';
                ctx.fillText(`获得金牌: ${gameState.player.collected}/${gameState.stars.length}`, canvas.width / 2, canvas.height / 2);
                
                // 绘制重新开始按钮
                const buttonWidth = 180;
                const buttonHeight = 50;
                const buttonX = canvas.width / 2 - buttonWidth / 2;
                const buttonY = canvas.height / 2 + 40;
                
                // 按钮背景
                ctx.fillStyle = gameState.isFullCollection ? '#FFD700' : '#4a90e2';
                ctx.fillRect(buttonX, buttonY, buttonWidth, buttonHeight);
                
                // 按钮文字
                ctx.fillStyle = gameState.isFullCollection ? '#000000' : '#ffffff';
                ctx.font = 'bold 20px Arial';
                ctx.fillText('再玩一次', canvas.width / 2, buttonY + buttonHeight / 2 + 7);
                
                // 保存按钮信息供点击检测使用
                gameState.restartButton = {
                    x: buttonX,
                    y: buttonY,
                    width: buttonWidth,
                    height: buttonHeight
                };
                
                // 添加点击事件监听，用于重新开始游戏
                if (!gameState.restartListenerAdded) {
                    canvas.addEventListener('click', restartGame);
                    canvas.addEventListener('touchstart', restartGame);
                    gameState.restartListenerAdded = true;
                }
                
                // 添加作者署名
                ctx.font = 'bold 18px Arial';
                ctx.fillStyle = gameState.isFullCollection ? '#FFD700' : '#dddddd';
                ctx.fillText('BY：刺', canvas.width / 2, canvas.height - 30);
            }
            
            // 绘制游戏结束画面
            function drawGameOver() {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 36px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('游戏结束', canvas.width / 2, canvas.height / 2 - 50);
                
                // 根据收集的金牌数量显示不同的失败提示文字
                const collectedCount = gameState.player.collected;
                let failureMessage = '';
                
                // 分档设置不同的文字
                if (collectedCount < 20) {
                    failureMessage = "“算了吧这个，有点不好说”";
                } else if (collectedCount >= 20 && collectedCount <= 39) {
                    failureMessage = "“而且在这么难游的池子里”";
                } else if (collectedCount >= 40 && collectedCount <= 59) {
                    failureMessage = "“证明我的实力已经达到了”";
                } else if (collectedCount >= 60 && collectedCount <= 72) {
                    failureMessage = "“我还想吃老甲鱼老牛蛙”";
                } else if (collectedCount >= 73 && collectedCount <= 83) {
                    failureMessage = "“回去把那两只的猫的毛都给撸得倒过来”";
                }
                
                // 显示失败提示文字
                ctx.font = 'bold 24px Arial';
                ctx.fillText(failureMessage, canvas.width / 2, canvas.height / 2 - 10);
                
                // 显示金牌统计
                ctx.font = '24px Arial';
                ctx.fillText(`获得金牌: ${gameState.player.collected}/${gameState.stars.length}`, canvas.width / 2, canvas.height / 2 + 20);
                
                // 绘制重新开始按钮
                const buttonWidth = 180;
                const buttonHeight = 50;
                const buttonX = canvas.width / 2 - buttonWidth / 2;
                const buttonY = canvas.height / 2 + 40;
                
                // 按钮背景
                ctx.fillStyle = '#4a90e2';
                ctx.fillRect(buttonX, buttonY, buttonWidth, buttonHeight);
                
                // 按钮文字
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 20px Arial';
                ctx.fillText('再玩一次', canvas.width / 2, buttonY + buttonHeight / 2 + 7);
                
                // 保存按钮信息供点击检测使用
                gameState.restartButton = {
                    x: buttonX,
                    y: buttonY,
                    width: buttonWidth,
                    height: buttonHeight
                };
                
                // 添加作者署名
                ctx.font = 'bold 18px Arial';
                ctx.fillStyle = '#dddddd';
                ctx.fillText('BY：刺', canvas.width / 2, canvas.height - 30);
            }
            
            // 重新开始游戏
            function restartGame(event) {
                // 检查点击是否在按钮上
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                
                let clickX, clickY;
                
                if (event.type === 'touchstart') {
                    clickX = (event.touches[0].clientX - rect.left) * scaleX;
                    clickY = (event.touches[0].clientY - rect.top) * scaleY;
                } else {
                    clickX = (event.clientX - rect.left) * scaleX;
                    clickY = (event.clientY - rect.top) * scaleY;
                }
                
                const button = gameState.restartButton;
                
                // 检查点击是否在按钮上
                const isButtonClicked = 
                    clickX >= button.x && 
                    clickX <= button.x + button.width && 
                    clickY >= button.y && 
                    clickY <= button.y + button.height;
                
                // 如果游戏已经结束或胜利，并且点击在按钮上，重新开始游戏
                if ((gameState.gameOver || gameState.victory) && isButtonClicked) {
                    // 移除事件监听器
                    canvas.removeEventListener('click', restartGame);
                    canvas.removeEventListener('touchstart', restartGame);
                    gameState.restartListenerAdded = false;
                    
                    // 重置游戏状态
                    initGameState();
                    createPirateScene();
                    
                    // 重新初始化玩家
                    gameState.player.lastSteppedPlatforms = [];
                    gameState.gameStarted = true;
                    gameState.gameOver = false;
                    gameState.victory = false;
                    
                    // 确保宝箱状态重置
                    if (gameState.chest) {
                        gameState.chest.currentFrame = 0;
                        gameState.chest.isAnimating = false;
                        gameState.chest.isOpened = false;
                        gameState.chest.animationTimer = 0;
                    }
                    
                    // 重置金币雨
                    gameState.goldRain.active = false;
                    gameState.goldRain.duration = 0;
                }
            }

            // 重置茶道具函数
            function resetTeas() {
                // 清空茶数组和计数
                gameState.teas = [];
                gameState.collectedTeas = 0;
                gameState.teaSpawnTimer = 0;
                
                // 重新创建初始茶
                createTeas();
                
                // 添加一个提示消息
                console.log("茶道具已重新刷新");
            }

            // 修改initGameState函数，重置初始气泡状态
            function initGameState() {
                // 重置游戏状态
                if (gameState) {
                    // 已有游戏状态，仅重置必要部分
                    gameState.gameStarted = false;
                    gameState.gameOver = false;
                    gameState.victory = false;
                    gameState.victoryPending = false; // 重置胜利等待状态
                    gameState.victoryDelay = 0; // 重置胜利延迟
                    gameState.isFullCollection = false; // 重置全收集特殊状态
                    gameState.camera = { x: 0, y: 0 };
                    gameState.frameCount = 0;
                    gameState.player.x = 50;
                    gameState.player.y = 100; // 调整初始玩家位置更高
                    gameState.player.velocityX = 0;
                    gameState.player.velocityY = 0;
                    gameState.player.collected = 0;
                    gameState.player.isJumping = false;
                    gameState.player.jumpCount = 0;
                    gameState.player.teaEffect.active = false;
                    gameState.player.onStartBubble = true; // 重置初始气泡状态
                    gameState.startBubble = null; // 清空初始气泡对象
                    gameState.collectedTeas = 0;
                    gameState.gameStartTime = Date.now(); // 记录游戏开始时间
                    gameState.bubbleIntervalNormalized = false; // 重置气泡间隔标志
                    
                    // 设置气泡生成器的快速初始间隔
                    for (const spawner of gameState.bubbleSpawners) {
                        spawner.normalInterval = spawner.interval; // 保存正常间隔
                        spawner.interval = spawner.interval * 0.5; // 初始间隔为正常间隔的一半，更快刷新
                    }
                    
                    // 重置宝箱状态
                    if (gameState.chest) {
                        gameState.chest.currentFrame = 0;
                        gameState.chest.isAnimating = false;
                        gameState.chest.isOpened = false;
                        gameState.chest.animationTimer = 0;
                    }
                    
                    // 清空粒子和平台
                    gameState.particles = [];
                    gameState.platforms = [];
                    gameState.teas = [];
                    gameState.stars = [];
                    gameState.pirateElements = [];
                } else {
                    // 首次初始化
                    gameState = {
                        gameStarted: false,
                        camera: { x: 0, y: 0 },
                        gravity: 0.5,
                        frameCount: 0,
                        particles: [],
                        platforms: [],
                        pirateElements: [],
                        stars: [],
                        teas: [],
                        collectedTeas: 0,
                        teaSpawnTimer: 0,
                        teaSpawnInterval: 8000,
                        gameOver: false,
                        victory: false,
                        victoryPending: false, // 是否正在等待胜利
                        victoryDelay: 0, // 胜利延迟帧数
                        isFullCollection: false, // 是否为全收集特殊状态
                        startBubble: null, // 添加初始气泡对象
                        goldRain: {      // 金币雨状态
                            active: false,
                            duration: 0,
                            nextSpawn: 0,
                            spawnInterval: 3
                        },
                        gmPanel: null,  // GM指令面板
                        gmMessage: null, // GM消息
                        godMode: false   // 无敌模式
                        // 其他属性保持不变
                    };
                    
                    // 添加玩家
                    gameState.player = {
                        x: 50,
                        y: 100, // 修改初始Y位置，与上面保持一致
                        width: 30,
                        height: 50,
                        velocityX: 0,
                        velocityY: 0,
                        speed: 3.5,
                        jumpForce: 5,
                        gravity: 0.2, // 确保重力参数存在
                        isJumping: false,
                        jumpCount: 0,
                        maxJumps: 2,
                        facingRight: true,
                        color: '#ff5a5f',
                        collected: 0,
                        sprite: null,
                        frameWidth: 1280,
                        frameHeight: 760,
                        currentFrame: 0,
                        currentRow: 0,
                        frameCount: 5,
                        animationSpeed: 0.15,
                        animationTimer: 0,
                        isRunning: false,
                        teaEffect: {
                            active: false,
                            duration: 0,
                            maxDuration: 180,
                            particles: []
                        },
                        onStartBubble: true, // 添加初始气泡状态
                        lastSteppedPlatforms: []
                    };
                    
                    // 设置键盘控制
                    gameState.keys = {
                        left: false,
                        right: false,
                        jump: false
                    };
                    
                    // 添加气泡平台生成点
                    gameState.bubbleSpawners = [
                        // 气泡生成点数组保持不变
                    ];
                    
                    // 终点平台
                    gameState.endPlatform = { 
                        x: 17000, 
                        y: 140, 
                        width: 180,  // 与固定平台相同的宽度
                        height: 20,  // 与固定平台相同的高度
                        color: '#5a7a95', // 与固定平台相同的颜色
                        isSeaStyle: true // 使用海底风格
                    };
                    // 移除旗帜初始化，完全使用宝箱
                    // 添加宝箱相关属性
                    gameState.chest = {
                        x: 17030, 
                        y: 60,           // 上移宝箱位置以适应更大的尺寸
                        width: 140,      // 宽度增加到两倍
                        height: 140,     // 高度增加到两倍
                        sprite: chestSprite, // 使用已加载的精灵图
                        frameWidth: 50,  // 每帧宽度
                        frameHeight: 50, // 每帧高度
                        totalFrames: 7,  // 总帧数
                        currentFrame: 0,
                        animationSpeed: 0.15,
                        animationTimer: 0,
                        isAnimating: false,
                        isOpened: false,
                        color: '#77dd77',  // 保留颜色属性，用于备用显示
                        useDrawnChest: false // 是否使用绘制的宝箱，而不是精灵图
                    };
                    
                    // 调整宝箱位置以适应终点平台
                    gameState.chest.x = gameState.endPlatform.x + (gameState.endPlatform.width / 2) - (gameState.chest.width / 2);
                    gameState.chest.y = gameState.endPlatform.y - gameState.chest.height - 5;
                    
                    // 添加固定平台
                    gameState.staticPlatforms = [
                        // 关卡开始位置附近
                        { x: 600, y: 250, width: 150, height: 20, color: '#5a7a95' },
                        // 关卡前部位置
                        { x: 1800, y: 280, width: 180, height: 20, color: '#5a7a95' },
                        // 关卡前中部位置
                        { x: 3200, y: 280, width: 200, height: 20, color: '#5a7a95' },
                        // 关卡中间位置
                        { x: 4800, y: 220, width: 180, height: 20, color: '#5a7a95' },
                        // 关卡中间偏后位置
                        { x: 6500, y: 260, width: 200, height: 20, color: '#5a7a95' },
                        // 关卡后段中部
                        { x: 8000, y: 220, width: 180, height: 20, color: '#5a7a95' },
                        // 新增平台以覆盖延长的关卡
                        // 关卡后段
                        { x: 9900, y: 250, width: 200, height: 20, color: '#5a7a95' },
                        // 关卡末端前
                        { x: 13000, y: 230, width: 170, height: 20, color: '#5a7a95' },
                        { x: 15500, y: 230, width: 170, height: 20, color: '#5a7a95' }
                    ];
                    
                    console.log("游戏状态已初始化");
                }
            }

            // 添加检测玩家与尖刺碰撞的函数
            function checkSpikesCollision() {
                // 如果没有初始化尖刺数组，跳过检测
                if (!gameState.spikesArray || !Array.isArray(gameState.spikesArray)) {
                    return;
                }
                
                // 如果玩家处于茶效果保护状态，跳过检测
                if (gameState.player.teaEffect.active) {
                    return;
                }
                
                // 检查玩家与尖刺的碰撞
                for (const spike of gameState.spikesArray) {
                    // 调整碰撞检测范围，使其更精确 - 缩小10%的检测区域
                    const adjustedSpike = {
                        x: spike.x + spike.width * 0.1,
                        y: spike.y + spike.height * 0.1,
                        width: spike.width * 0.8,
                        height: spike.height * 0.8
                    };
                    
                    if (checkCollision(gameState.player, adjustedSpike)) {
                        console.log("玩家碰到尖刺");
                        
                        // 使用专门的处理函数处理尖刺碰撞
                        handleSpikesHit();
                        
                        return; // 检测到碰撞后退出函数
                    }
                }
            }
            
            // 添加处理玩家接触尖刺的函数
            function handleSpikesHit() {
                const player = gameState.player;
                
                // 创建玩家失败粒子效果
                createFallEffect(player.x + player.width/2, player.y + player.height/2);
                
                // 检查是否有茶道具可用
                if (gameState.collectedTeas > 0) {
                    // 找到最近踩踏过的固定平台
                    let respawnPlatform = null;
                    
                    if (player.lastSteppedPlatforms.length > 0) {
                        // 使用最近踩踏的平台
                        respawnPlatform = player.lastSteppedPlatforms[0];
                        console.log("复活到最近踩踏的平台:", respawnPlatform.x, respawnPlatform.y);
                    } else {
                        // 如果没有踩踏记录，继续使用原来的查找最近平台的方法
                        respawnPlatform = findNearestStaticPlatform(player.x);
                        console.log("没有踩踏记录，复活到最近的平台:", respawnPlatform ? respawnPlatform.x : "无平台");
                    }
                    
                    if (respawnPlatform) {
                        // 消耗一个茶道具
                        gameState.collectedTeas--;
                        
                        // 在固定平台上复活玩家
                        player.x = respawnPlatform.x + respawnPlatform.width / 2 - player.width / 2;
                        player.y = respawnPlatform.y - player.height;
                        player.velocityY = 0;
                        player.isJumping = false;
                        
                        // 创建复活特效
                        createRespawnEffect(player.x + player.width/2, player.y + player.height/2);
                        
                        // 激活茶效果状态
                        activateTeaEffect(player);
                        
                        // 不重置收集物状态，保持坠落时的样子
                    } else {
                        // 没有找到合适的平台，在起点复活并消耗茶道具
                        gameState.collectedTeas--;
            player.x = 50;
                        player.y = 300;  // 修改复活高度
            player.velocityY = 0;
                        player.isJumping = false;
                        createRespawnEffect(player.x + player.width/2, player.y + player.height/2);
                        
                        // 激活茶效果状态
                        activateTeaEffect(player);
                    }
                } else {
                    // 没有茶道具，游戏结束
                    gameState.gameOver = true;
                    
                    // 播放游戏失败音效
                    playSound('gameOver');
                    
                    // 添加点击事件监听，用于重新开始游戏
                    if (!gameState.restartListenerAdded) {
                        canvas.addEventListener('click', restartGame);
                        canvas.addEventListener('touchstart', restartGame);
                        gameState.restartListenerAdded = true;
                    }
                }
            }

            // 添加更新宝箱动画的函数
            function updateChestAnimation(elapsed) {
                const chest = gameState.chest;
                
                if (chest && chest.isAnimating) {
                    // 更新宝箱动画 - 基于时间的更新
                    chest.animationTimer += chest.animationSpeed * 60 * elapsed * gameState.time.timeScale;
                    
                    if (chest.animationTimer >= 1) {
                        chest.animationTimer = 0;
                        chest.currentFrame++;
                        
                        if (chest.currentFrame >= chest.totalFrames) {
                            chest.currentFrame = chest.totalFrames - 1; // 停在最后一帧
                            chest.isAnimating = false;
                            chest.isOpened = true;
                            console.log("宝箱动画完成，停在最后一帧");
                            
                            // 检查是否收集了全部金牌
                            const isFullCollection = gameState.player.collected === gameState.stars.length && gameState.stars.length > 0;
                            
                            // 播放对应的音效
                            if (isFullCollection) {
                                // 播放全收集特殊音效
                                console.log("播放全收集特殊音效");
                                playSound('fullCollection');
                            } else {
                                // 播放普通胜利音效
                                playSound('victory');
                            }
                            
                            // 宝箱开启时创建金币和星星粒子效果
                            createChestOpeningEffect(chest);
                            
                            // 检查是否收集了全部金牌，如果是则创建金币雨效果
                            if (isFullCollection) {
                                console.log("收集了全部金牌，创建金币雨！");
                                createGoldRainEffect();
                            }
                        }
                    }
                }
            }

            // 添加绘制自定义宝箱的函数
            function drawCustomChest(chest) {
                const x = chest.x - gameState.camera.x;
                const y = chest.y - gameState.camera.y;
                const width = chest.width;
                const height = chest.height;
                
                // 确定宝箱状态
                const isOpen = chest.isOpened || (chest.isAnimating && chest.currentFrame >= 4);
                
                // 宝箱底部和顶部的比例
                const baseHeight = height * 0.7;
                const lidHeight = height - baseHeight;
                
                // 宝箱底部 - 深棕色
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(x, y + lidHeight, width, baseHeight);
                
                // 宝箱盖 - 浅棕色
                ctx.fillStyle = isOpen ? '#D2691E' : '#A0522D';
                
                if (isOpen) {
                    // 开启状态 - 宝箱盖打开
                    ctx.beginPath();
                    ctx.moveTo(x, y + lidHeight);
                    ctx.lineTo(x + width, y + lidHeight);
                    ctx.lineTo(x + width * 0.8, y - lidHeight * 0.5);
                    ctx.lineTo(x + width * 0.2, y - lidHeight * 0.5);
                    ctx.closePath();
                    ctx.fill();
                    
                    // 宝箱内部 - 金色
                    ctx.fillStyle = '#FFD700';
                    ctx.fillRect(x + width * 0.1, y + lidHeight + 5, width * 0.8, baseHeight - 10);
                    
                    // 宝箱内光芒
                    const gradient = ctx.createRadialGradient(
                        x + width/2, y + height/2, 0,
                        x + width/2, y + height/2, width/2
                    );
                    gradient.addColorStop(0, 'rgba(255, 215, 0, 0.7)');
                    gradient.addColorStop(1, 'rgba(255, 215, 0, 0)');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(x + width/2, y + height/2, width/2, 0, Math.PI * 2);
                    ctx.fill();
                    
                } else {
                    // 关闭状态 - 宝箱盖闭合
                    ctx.fillRect(x, y, width, lidHeight);
                    
                    // 宝箱装饰 - 锁和边缘
                    ctx.fillStyle = '#FFD700'; // 金色装饰
                    ctx.fillRect(x + width * 0.4, y + lidHeight * 0.3, width * 0.2, lidHeight * 0.4);
                    
                    // 宝箱边缘
                    ctx.fillRect(x, y + lidHeight - 2, width, 4);
                }
                
                // 宝箱边框
                ctx.strokeStyle = '#4A3728';
                ctx.lineWidth = 2;
                ctx.strokeRect(x, y, width, height);
                
                // 当宝箱处于动画状态时添加一些活动效果
                if (chest.isAnimating) {
                    // 添加一些闪光粒子效果
                    const particleCount = 3 + Math.floor(Math.random() * 3);
                    for (let i = 0; i < particleCount; i++) {
                        const particleX = x + width/2 + (Math.random() - 0.5) * width;
                        const particleY = y + height/2 + (Math.random() - 0.5) * height;
                        const particleSize = 1 + Math.random() * 3;
                        
                        ctx.fillStyle = 'rgba(255, 215, 0, 0.8)';
                        ctx.beginPath();
                        ctx.arc(particleX, particleY, particleSize, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }
            
            // 添加宝箱开启时的特效
            function createChestOpeningEffect(chest) {
                // 计算宝箱中心点（世界坐标）
                const centerX = chest.x + chest.width / 2;
                const centerY = chest.y + chest.height / 2;
                
                // 检查是否为全收集特殊状态
                const isFullCollection = gameState.isFullCollection;
                
                console.log("创建宝箱开启特效，位置:", centerX, centerY, 
                    isFullCollection ? "- 全收集特殊状态" : "");
                
                // 创建金币粒子, 全收集状态下增加数量
                const coinCount = isFullCollection ? 
                    30 + Math.floor(Math.random() * 20) : // 全收集状态：30-50个 
                    15 + Math.floor(Math.random() * 10);  // 普通状态：15-25个
                    
                for (let i = 0; i < coinCount; i++) {
                    // 随机选择粒子类型：金币、星星或钻石
                    // 全收集状态下增加钻石和星星的出现概率
                    const particleType = isFullCollection ?
                        (Math.random() < 0.4 ? 'coin' : (Math.random() < 0.6 ? 'star' : 'diamond')) :
                        (Math.random() < 0.6 ? 'coin' : (Math.random() < 0.8 ? 'star' : 'diamond'));
                    
                    // 设置初始速度和方向
                    const angle = Math.random() * Math.PI; // 上半圆范围内
                    const speed = 4 + Math.random() * 6;
                    const lifetime = 60 + Math.floor(Math.random() * 120);
                    
                    // 创建粒子
                    gameState.particles.push({
                        x: centerX,
                        y: centerY - 20, // 从宝箱顶部位置开始
                        velocityX: Math.cos(angle) * speed * (Math.random() > 0.5 ? 1 : -1),
                        velocityY: -Math.sin(angle) * speed,
                        size: particleType === 'coin' ? 8 + Math.random() * 5 : 4 + Math.random() * 3,
                        color: particleType === 'coin' ? '#FFD700' : (particleType === 'star' ? '#FFFF00' : '#00FFFF'),
                        gravity: 0.15,
                        friction: 0.98,
                        life: lifetime,
                        maxLife: lifetime,
                        rotation: Math.random() * Math.PI * 2,
                        rotationSpeed: (Math.random() - 0.5) * 0.2,
                        type: particleType,
                        bounced: false,
                        scale: 1,
                        opacity: 1,
                        isFullCollectionParticle: isFullCollection // 标记是否为全收集特殊状态的粒子
                    });
                }
                
                // 创建持续的闪光效果
                chest.glowEffects = {
                    active: true,
                    intensity: isFullCollection ? 1.2 : 0.8, // 全收集状态下增强光晕强度
                    particles: [],
                    nextSpawn: 0
                };
                
                // 初始化一些闪光粒子, 全收集状态下增加数量
                for (let i = 0; i < (isFullCollection ? 20 : 10); i++) {
                    addChestGlowParticle(chest);
                }
            }
            
            // 添加宝箱持续闪光粒子
            function addChestGlowParticle(chest) {
                // 基于宝箱的位置创建闪光粒子
                const centerX = chest.x + chest.width / 2;
                const centerY = chest.y + chest.height / 2;
                
                // 随机偏移，使粒子分布在宝箱周围
                const offsetRange = Math.max(chest.width, chest.height) * 0.8;
                const offsetX = (Math.random() - 0.5) * offsetRange;
                const offsetY = (Math.random() - 0.5) * offsetRange;
                
                // 闪光粒子类型：小星星或光点
                const isGlitter = Math.random() > 0.6;
                
                // 设置粒子参数
                const size = isGlitter ? 2 + Math.random() * 3 : 1 + Math.random() * 2;
                const lifetime = 30 + Math.floor(Math.random() * 30);
                
                // 添加到闪光粒子数组
                chest.glowEffects.particles.push({
                    x: centerX + offsetX,
                    y: centerY + offsetY,
                    size: size,
                    color: isGlitter ? '#FFFFFF' : (Math.random() > 0.5 ? '#FFD700' : '#FFFF99'),
                    life: lifetime,
                    maxLife: lifetime,
                    isGlitter: isGlitter,
                    speed: 0.1 + Math.random() * 0.3,
                    angle: Math.random() * Math.PI * 2,
                    distance: Math.random() * (offsetRange * 0.3),
                    initialX: centerX + offsetX,
                    initialY: centerY + offsetY,
                    pulsate: Math.random() * Math.PI * 2, // 起始相位
                    pulsateSpeed: 0.05 + Math.random() * 0.1 // 脉动速度
                });
            }
            
            // 更新宝箱闪光效果
            function updateChestGlowEffects() {
                const chest = gameState.chest;
                
                // 如果宝箱没有打开或没有闪光效果，直接返回
                if (!chest.isOpened || !chest.glowEffects || !chest.glowEffects.active) return;
                
                // 更新现有闪光粒子
                for (let i = chest.glowEffects.particles.length - 1; i >= 0; i--) {
                    const particle = chest.glowEffects.particles[i];
                    
                    // 更新生命周期
                    particle.life--;
                    
                    if (particle.life <= 0) {
                        // 在全收集特殊状态下，如果还在胜利等待中，闪光粒子不会完全消失
                        if (gameState.isFullCollection && gameState.victoryPending && !gameState.victory) {
                            // 恢复一定生命值，但随时间逐渐减少恢复量
                            const recoveryFactor = gameState.victoryDelay / 600; // 基于剩余延迟比例
                            particle.life = Math.max(5, Math.floor(20 * recoveryFactor));
                        } else {
                            // 移除死亡粒子
                            chest.glowEffects.particles.splice(i, 1);
                            continue;
                        }
                    }
                    
                    // 更新闪烁粒子的位置
                    if (particle.isGlitter) {
                        // 星星粒子沿轨迹移动
                        particle.angle += particle.speed;
                        particle.x = particle.initialX + Math.cos(particle.angle) * particle.distance;
                        particle.y = particle.initialY + Math.sin(particle.angle) * particle.distance;
                    }
                    
                    // 脉动透明度
                    particle.opacity = 0.3 + Math.sin(gameState.frameCount * 0.1 + particle.pulsate) * 0.7;
                }
                
                // 随机生成新的闪光粒子
                if (gameState.frameCount > chest.glowEffects.nextSpawn) {
                    // 全收集状态下生成更多粒子
                    const newParticleCount = gameState.isFullCollection ? 
                        2 + Math.floor(Math.random() * 3) : // 全收集状态：2-5个
                        1 + Math.floor(Math.random() * 3);  // 普通状态：1-3个
                        
                    for (let i = 0; i < newParticleCount; i++) {
                        addChestGlowParticle(chest);
                    }
                    
                    // 设置下一次生成时间，全收集状态下更频繁
                    const spawnInterval = gameState.isFullCollection ? 
                        3 + Math.floor(Math.random() * 5) : // 全收集状态：3-8帧
                        5 + Math.floor(Math.random() * 10); // 普通状态：5-15帧
                        
                    chest.glowEffects.nextSpawn = gameState.frameCount + spawnInterval;
                }
            }
            
            // 渲染宝箱闪光效果
            function renderChestGlowEffects() {
                const chest = gameState.chest;
                
                // 如果宝箱没有打开或没有闪光效果，直接返回
                if (!chest.isOpened || !chest.glowEffects || !chest.glowEffects.active) return;
                
                // 计算屏幕坐标
                const screenX = chest.x - gameState.camera.x;
                const screenY = chest.y - gameState.camera.y;
                const centerX = screenX + chest.width / 2;
                const centerY = screenY + chest.height / 2;
                
                // 绘制整体光晕
                const glowSize = Math.max(chest.width, chest.height) * 1.5;
                const glowIntensity = 0.4 + Math.sin(gameState.frameCount * 0.03) * 0.2;
                
                const glow = ctx.createRadialGradient(
                    centerX, centerY, 0,
                    centerX, centerY, glowSize
                );
                glow.addColorStop(0, `rgba(255, 215, 0, ${glowIntensity * 0.6})`);
                glow.addColorStop(0.5, `rgba(255, 215, 0, ${glowIntensity * 0.3})`);
                glow.addColorStop(1, 'rgba(255, 215, 0, 0)');
                
                ctx.fillStyle = glow;
                ctx.beginPath();
                ctx.arc(centerX, centerY, glowSize, 0, Math.PI * 2);
                ctx.fill();
                
                // 绘制闪光粒子
                for (const particle of chest.glowEffects.particles) {
                    const particleScreenX = particle.x - gameState.camera.x;
                    const particleScreenY = particle.y - gameState.camera.y;
                    
                    if (particle.isGlitter) {
                        // 绘制星形闪光
                        const opacity = particle.life / particle.maxLife * particle.opacity;
                        const starSize = particle.size * (0.7 + Math.sin(gameState.frameCount * 0.2) * 0.3);
                        
                        ctx.save();
                        ctx.translate(particleScreenX, particleScreenY);
                        ctx.rotate(gameState.frameCount * 0.03);
                        
                        ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
                        ctx.beginPath();
                        
                        // 绘制五角星
                        for (let i = 0; i < 5; i++) {
                            const angle = (i * Math.PI * 2 / 5) - Math.PI / 2;
                            const distance = i === 0 ? starSize : starSize * 0.4;
                            const x = Math.cos(angle) * distance;
                            const y = Math.sin(angle) * distance;
                            
                            if (i === 0) {
                                ctx.moveTo(x, y);
                            } else {
                                ctx.lineTo(x, y);
                            }
                        }
                        ctx.closePath();
                        ctx.fill();
                        ctx.restore();
                    } else {
                        // 绘制简单的光点
                        const opacity = particle.life / particle.maxLife * particle.opacity;
                        
                        ctx.fillStyle = `rgba(255, 215, 0, ${opacity})`;
                        ctx.beginPath();
                        ctx.arc(particleScreenX, particleScreenY, particle.size, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }

            // 创建金币雨效果 - 当玩家收集了全部金牌并开启宝箱时
            function createGoldRainEffect() {
                // 检查是否为全收集特殊状态
                const isFullCollection = gameState.isFullCollection;
                
                // 金币雨持续时间和间隔设置 - 基于时间而非帧数
                gameState.goldRain = {
                    active: true,
                    duration: isFullCollection ? 10 : 5,  // 全收集状态下持续10秒，否则5秒
                    lastSpawnTime: 0,   // 上次生成金币的时间
                    spawnInterval: 100  // 每100毫秒生成一波金币
                };
                
                // 立即生成第一波金币
                spawnGoldRainParticles();
                
                console.log("创建金币雨效果 - " + (isFullCollection ? "全收集特殊状态(10秒)" : "普通状态(5秒)"));
            }
            
            // 生成金币雨粒子
            function spawnGoldRainParticles() {
                // 检查是否为全收集特殊状态
                const isFullCollection = gameState.isFullCollection;
                
                // 在屏幕上方随机位置生成金币，全收集状态下生成更多
                const particleCount = isFullCollection ? 
                    30 + Math.floor(Math.random() * 15) : // 全收集状态：30-45个
                    20 + Math.floor(Math.random() * 10);  // 普通状态：20-30个
                
                for (let i = 0; i < particleCount; i++) {
                    // 随机选择粒子类型
                    // 全收集状态下增加钻石和星星的出现概率
                    const particleType = isFullCollection ?
                        (Math.random() < 0.4 ? 'coin' : (Math.random() < 0.6 ? 'star' : 'diamond')) :
                        (Math.random() < 0.6 ? 'coin' : (Math.random() < 0.8 ? 'star' : 'diamond'));
                    
                    // 随机屏幕位置（考虑相机位置，使金币出现在当前视野内）
                    const screenX = Math.random() * canvas.width;
                    const worldX = screenX + gameState.camera.x;
                    
                    // 生成粒子
                    gameState.particles.push({
                        x: worldX,
                        y: -20 - Math.random() * 50, // 屏幕上方稍有偏移
                        velocityX: (Math.random() - 0.5) * 2,  // 轻微左右漂移
                        velocityY: 3 + Math.random() * 4,      // 向下落
                        size: particleType === 'coin' ? 8 + Math.random() * 5 : 4 + Math.random() * 3,
                        color: particleType === 'coin' ? '#FFD700' : (particleType === 'star' ? '#FFFF00' : '#00FFFF'),
                        gravity: 0.1,
                        friction: 0.99,
                        life: 180 + Math.floor(Math.random() * 120), // 3-5秒的生命周期
                        maxLife: 180 + Math.floor(Math.random() * 120),
                        rotation: Math.random() * Math.PI * 2,
                        rotationSpeed: (Math.random() - 0.5) * 0.1,
                        type: particleType,
                        bounced: false,
                        scale: 1,
                        opacity: 1,
                        isGoldRain: true, // 标记为金币雨粒子
                        isFullCollectionParticle: isFullCollection // 标记是否为全收集特殊状态的粒子
                    });
                }
            }
            
            // 更新金币雨效果
            function updateGoldRainEffect() {
                // 如果金币雨不活跃，直接返回
                if (!gameState.goldRain || !gameState.goldRain.active) return;
                
                // 减少持续时间 - 直接使用elapsed，因为duration已经是以秒为单位
                gameState.goldRain.duration -= gameState.time.elapsed;
                
                // 检查是否应该生成新一波金币 - 基于实际时间而非帧数
                const currentTime = Date.now();
                if (!gameState.goldRain.lastSpawnTime || 
                    currentTime - gameState.goldRain.lastSpawnTime >= gameState.goldRain.spawnInterval) {
                    spawnGoldRainParticles();
                    gameState.goldRain.lastSpawnTime = currentTime;
                }
                
                // 如果持续时间结束，停止金币雨
                if (gameState.goldRain.duration <= 0) {
                    gameState.goldRain.active = false;
                    console.log("金币雨效果结束");
                }
            }

            // 添加GM指令系统的功能函数
            // 收集全部金牌
            function collectAllMedals() {
                if (!gameState.stars) return;
                
                // 标记所有金牌为已收集
                for (let i = 0; i < gameState.stars.length; i++) {
                    if (!gameState.stars[i].collected) {
                        gameState.stars[i].collected = true;
                        gameState.player.collected++;
                    }
                }
                
                // 设置全收集状态标志
                if (gameState.stars.length > 0 && gameState.player.collected === gameState.stars.length) {
                    gameState.isFullCollection = true;
                    console.log("已设置全收集特殊状态");
                }
                
                console.log(`已收集全部${gameState.stars.length}块金牌`);
                
                // 显示金币收集数量提示
                showGMMessage(`已收集全部${gameState.stars.length}块金牌!`);
            }
            
            // 传送到终点
            function teleportToEnd() {
                // 传送玩家到终点平台上方
                gameState.player.x = gameState.endPlatform.x + gameState.endPlatform.width/2 - gameState.player.width/2;
                gameState.player.y = gameState.endPlatform.y - gameState.player.height - 50;
                gameState.player.velocityY = 0;
                
                // 调整相机位置
                gameState.camera.x = gameState.player.x - canvas.width / 2;
                
                console.log("已传送到终点平台");
                showGMMessage("已传送到终点平台!");
            }
            
            // 切换无敌模式
            function toggleGodMode() {
                gameState.godMode = !gameState.godMode;
                console.log("无敌模式:", gameState.godMode ? "开启" : "关闭");
                showGMMessage(`无敌模式: ${gameState.godMode ? "开启" : "关闭"}`);
            }
            
            // 重置游戏
            function resetGame() {
                initGameState();
                createPirateScene();
                gameState.player.lastSteppedPlatforms = [];
                gameState.gameStarted = true;
                gameState.gameOver = false;
                gameState.victory = false;
                
                console.log("游戏已重置");
                showGMMessage("游戏已重置!");
            }
            
            // 显示GM命令执行消息
            function showGMMessage(message) {
                // 创建消息对象 - 使用基于秒的生命周期
                gameState.gmMessage = {
                    text: message,
                    life: 2, // 持续2秒
                    opacity: 1
                };
            }
            
            // 渲染GM消息
            function renderGMMessage() {
                if (!gameState.gmMessage || gameState.gmMessage.life <= 0) return;
                
                // 更新生命周期 - 基于秒的减少
                gameState.gmMessage.life -= gameState.time.elapsed;
                
                // 最后1/3的时间淡出
                if (gameState.gmMessage.life < 0.7) {
                    gameState.gmMessage.opacity = gameState.gmMessage.life / 0.7;
                }
                
                // 绘制消息
                ctx.fillStyle = `rgba(0, 0, 0, ${gameState.gmMessage.opacity * 0.7})`;
                ctx.fillRect(canvas.width/2 - 150, 20, 300, 40);
                
                ctx.fillStyle = `rgba(255, 255, 255, ${gameState.gmMessage.opacity})`;
                ctx.font = 'bold 20px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(gameState.gmMessage.text, canvas.width/2, 45);
                ctx.textAlign = 'left';
            }

            // 添加音频资源
            const audioFiles = {
                teaEffect: 'chayinxiao.mp3',       // 茶效果音效
                victory: 'shengliyinxiao.mp3',     // 胜利音效
                gameOver: 'shibaiyinxiao.mp3',     // 失败音效
                collectCoin: 'shoujijinbi.mp3',    // 收集金币音效
                bubblePop: 'qipaoposui.mp3',       // 气泡破裂音效
                fullCollection: 'quanshoujiyinxiao.mp3' // 全收集特殊音效
            };
            
            // 创建音频对象
            const sounds = {};
            
            // 初始化音频系统
            function initAudioSystem() {
                try {
                    // 检查浏览器的音频支持情况
                    const audioContext = window.AudioContext || window.webkitAudioContext;
                    gameState.audioSupported = !!audioContext;
                    
                    if (!gameState.audioSupported) {
                        console.warn("当前浏览器不完全支持音频API，游戏将在静音模式下运行。");
                        return;
                    }
                    
                    // 为不同浏览器准备多种格式的音频文件
                    const audioExtensions = ['.mp3', '.ogg', '.wav'];
                    
                    // 加载所有音效
                    for (const key in audioFiles) {
                        // 提取基础文件名（不含扩展名）
                        const fileBaseName = audioFiles[key].split('.')[0];
                        
                        // 尝试创建音频元素
                        sounds[key] = new Audio();
                        
                        // 设置音频属性
                        sounds[key].preload = 'auto';
                        sounds[key].volume = 0.5;
                        
                        // 检测不同格式的支持情况
                        let supportedFormat = '';
                        for (const ext of audioExtensions) {
                            if (sounds[key].canPlayType('audio/' + ext.substring(1)) !== '') {
                                supportedFormat = ext;
                                break;
                            }
                        }
                        
                        // 如果没有找到支持的格式，默认使用 mp3
                        if (!supportedFormat) {
                            supportedFormat = '.mp3';
                        }
                        
                        // 设置最终音频源
                        sounds[key].src = fileBaseName + supportedFormat;
                        
                        // 添加加载错误处理
                        sounds[key].onerror = function() {
                            console.warn(`音频文件 ${sounds[key].src} 加载失败，尝试使用备用格式`);
                            // 如果加载失败，尝试下一个扩展名
                            const currentExtIndex = audioExtensions.indexOf(supportedFormat);
                            if (currentExtIndex < audioExtensions.length - 1) {
                                supportedFormat = audioExtensions[currentExtIndex + 1];
                                sounds[key].src = fileBaseName + supportedFormat;
                            } else {
                                console.error(`所有音频格式都无法加载: ${fileBaseName}`);
                            }
                        };
                        
                        // 预加载音频
                        try {
                            sounds[key].load();
                        } catch (e) {
                            console.warn(`预加载音频 ${key} 时出错:`, e);
                        }
                    }
                    
                    // 为移动设备设置允许自动播放的标志
                    gameState.mobileAudioEnabled = false;
                    
                    // 使用用户交互事件解锁音频（针对iOS和其他移动设备）
                    const unlockAudio = function() {
                        if (gameState.mobileAudioEnabled) return;
                        
                        // 创建临时的静音音频并播放，解锁后续音频播放
                        const silentSound = new Audio();
                        silentSound.src = "data:audio/mp3;base64,SUQzBAAAAAABEVRYWFgAAAAtAAADY29tbWVudABCaWdTb3VuZEJhbmsuY29tIC8gTGFTb25vdGhlcXVlLm9yZwBURU5DAAAAHQAAA1N3aXRjaCBQbHVzIMKpIE5DSCBTb2Z0d2FyZQBUSVQyAAAABgAAAzIyMzUAVFNTRQAAAA8AAANMYXZmNTcuODMuMTAwAAAAAAAAAAAAAAD/80DEAAAAA0gAAAAATEFNRTMuMTAwVVVVVVVVVVVVVUxBTUUzLjEwMFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVf/zQsRbAAADSAAAAABVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVf/zQMSkAAADSAAAAABVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV";
                        silentSound.play().then(function() {
                            gameState.mobileAudioEnabled = true;
                            console.log("音频系统已为移动设备解锁");
                            
                            // 移除事件监听器
                            document.removeEventListener('touchstart', unlockAudio);
                            document.removeEventListener('click', unlockAudio);
                        }).catch(function(error) {
                            console.warn("无法解锁移动设备音频:", error);
                        });
                    };
                    
                    // 添加用户交互事件监听器来解锁音频
                    document.addEventListener('touchstart', unlockAudio, false);
                    document.addEventListener('click', unlockAudio, false);
                    
                    console.log("音频系统已初始化");
                } catch (error) {
                    console.error("初始化音频系统时出错:", error);
                    gameState.audioSupported = false;
                }
            }
            
            // 播放音效函数
            function playSound(soundName) {
                // 如果浏览器不支持音频或声音对象不存在，直接返回
                if (!gameState.audioSupported || !sounds[soundName]) {
                    return;
                }
                
                try {
                    // 在iOS上，必须在用户交互后才能播放音频
                    if (isIOS() && !gameState.mobileAudioEnabled) {
                        console.log(`在iOS上跳过播放音效 ${soundName}，等待用户交互`);
                        return;
                    }
                    
                    // 创建音频克隆，避免多次播放同一个音频对象导致冲突
                    let soundClone;
                    try {
                        soundClone = sounds[soundName].cloneNode();
                    } catch (e) {
                        // 如果克隆失败，尝试直接使用原始对象
                        console.warn(`无法克隆音频对象，将直接使用原始音频:`, e);
                        soundClone = sounds[soundName];
                        // 重置音频到开始位置
                        soundClone.currentTime = 0;
                    }
                    
                    // 设置音量
                    soundClone.volume = 0.5;
                    
                    // 使用异步方式播放音效
                    const playPromise = soundClone.play();
                    
                    // 处理播放承诺（如果存在）
                    if (playPromise !== undefined) {
                        playPromise.catch(function(error) {
                            console.warn(`播放音效 ${soundName} 时出错:`, error);
                            
                            // 如果错误是由于用户未交互导致的，标记为需要用户交互
                            if (error.name === 'NotAllowedError') {
                                gameState.mobileAudioEnabled = false;
                                console.log("音频播放被浏览器阻止，等待用户交互");
                            }
                        });
                    }
                } catch (error) {
                    console.error(`播放音效 ${soundName} 时出错:`, error);
                    // 音效播放失败不应影响游戏
                }
            }
            
            // 辅助函数：检测是否为iOS设备
            function isIOS() {
                return /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
            }

            // 修改绘制尖刺的函数
            function drawSpikes() {
                // 如果未初始化尖刺数组，跳过绘制
                if (!gameState.spikesArray || !Array.isArray(gameState.spikesArray)) {
                    return;
                }
                
                const cameraX = gameState.camera.x;
                
                // 仅绘制在画面范围内的尖刺
                for (const spike of gameState.spikesArray) {
                    const screenX = spike.x - cameraX;
                    
                    // 如果尖刺在屏幕外，跳过绘制
                    if (screenX < -spike.width || screenX > canvas.width) {
                        continue;
                    }
                    
                    // 创建尖刺渐变
                    const gradient = ctx.createLinearGradient(
                        screenX, spike.y,
                        screenX, spike.y + spike.height
                    );
                    gradient.addColorStop(0, gameState.spikes.tipColor);
                    gradient.addColorStop(1, gameState.spikes.baseColor);
                    
                    // 绘制尖刺
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.moveTo(screenX, spike.y + spike.height);
                    ctx.lineTo(screenX + spike.width / 2, spike.y);
                    ctx.lineTo(screenX + spike.width, spike.y + spike.height);
                    ctx.fill();
                    
                    // 添加尖刺发光效果
                    ctx.fillStyle = gameState.spikes.glowColor;
                    ctx.beginPath();
                    ctx.moveTo(screenX, spike.y + spike.height);
                    ctx.lineTo(screenX + spike.width / 2, spike.y);
                    ctx.lineTo(screenX + spike.width, spike.y + spike.height);
                    ctx.fill();
                }
            }

            // 添加调试键绑定
            window.addEventListener('keydown', function(e) {
                if (e.key === 'F12') {
                    gameState.debug = !gameState.debug;
                    console.log(`调试模式: ${gameState.debug ? '开启' : '关闭'}`);
                }
                
                // 调试模式下的时间控制
                if (gameState.debug) {
                    if (e.key === '[') {
                        // 减慢游戏时间
                        gameState.time.timeScale = Math.max(0.1, gameState.time.timeScale - 0.1);
                        console.log(`时间比例: ${gameState.time.timeScale.toFixed(1)}`);
                    } else if (e.key === ']') {
                        // 加快游戏时间
                        gameState.time.timeScale = Math.min(2.0, gameState.time.timeScale + 0.1);
                        console.log(`时间比例: ${gameState.time.timeScale.toFixed(1)}`);
                    } else if (e.key === '\\') {
                        // 重置时间比例
                        gameState.time.timeScale = 1.0;
                        console.log(`时间比例重置: ${gameState.time.timeScale.toFixed(1)}`);
                    }
                }
            });

            // 添加调试信息显示
            function drawDebugInfo() {
                if (!gameState.debug) return;
                
                // 绘制半透明背景
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(10, 10, 250, 120);
                
                // 设置文字样式
                ctx.font = '14px monospace';
                ctx.fillStyle = 'white';
                ctx.textAlign = 'left';
                
                // 显示FPS和时间信息
                const fps = Math.round(1 / gameState.time.elapsed);
                const timeInfo = [
                    `FPS: ${fps}`,
                    `时间比例: ${gameState.time.timeScale.toFixed(2)}x`,
                    `实际帧时间: ${(gameState.time.elapsed * 1000).toFixed(2)}ms`,
                    `修正帧时间: ${(gameState.time.elapsed * gameState.time.timeScale * 1000).toFixed(2)}ms`,
                    `玩家位置: (${Math.round(gameState.player.x)}, ${Math.round(gameState.player.y)})`,
                    `速度: (${gameState.player.velocityX.toFixed(1)}, ${gameState.player.velocityY.toFixed(1)})`,
                    `跳跃状态: ${gameState.player.isJumping ? '跳跃中' : '站立'} (${gameState.player.jumpCount}/${gameState.player.maxJumps})`
                ];
                
                // 绘制信息
                timeInfo.forEach((line, index) => {
                    ctx.fillText(line, 20, 30 + index * 16);
                });
                
                // 绘制控制说明
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(canvas.width - 210, 10, 200, 75);
                ctx.fillStyle = 'white';
                
                const helpLines = [
                    "调试控制:",
                    "F12: 切换调试模式",
                    "[/]: 减慢/加快时间",
                    "\\: 重置时间为正常速度"
                ];
                
                helpLines.forEach((line, index) => {
                    ctx.fillText(line, canvas.width - 200, 30 + index * 16);
                });
            }

            // 音频系统
            const audioSystem = {
                sounds: {},
                isInitialized: false,
                audioContext: null,
                gainNode: null,
                isAudioContextSuspended: false,
                lastPlayTime: 0,
                playInterval: 100, // 最小播放间隔（毫秒）
                bufferSize: 5, // 音频缓冲池大小
                bufferPool: {}, // 音频缓冲池
                isAudioUnlocked: false, // 添加音频解锁状态
                init() {
                    try {
                        // 创建音频上下文
                        const AudioContext = window.AudioContext || window.webkitAudioContext;
                        this.audioContext = new AudioContext();
                        this.gainNode = this.audioContext.createGain();
                        this.gainNode.connect(this.audioContext.destination);
                        
                        // 预加载所有音频
                        this.preloadSounds();
                        
                        // 添加音频上下文状态监控
                        this.monitorAudioContext();
                        
                        // 添加用户交互监听
                        this.addUserInteractionListeners();
                        
                        this.isInitialized = true;
                        console.log("音频系统初始化成功");
                    } catch (error) {
                        console.error("音频系统初始化失败:", error);
                    }
                },
                
                // 添加用户交互监听
                addUserInteractionListeners() {
                    const unlockAudio = () => {
                        if (!this.isAudioUnlocked && this.audioContext) {
                            // 创建一个空的音频缓冲区
                            const buffer = this.audioContext.createBuffer(1, 1, 22050);
                            const source = this.audioContext.createBufferSource();
                            source.buffer = buffer;
                            source.connect(this.audioContext.destination);
                            
                            // 播放并立即停止
                            source.start(0);
                            source.stop(0);
                            
                            this.isAudioUnlocked = true;
                            console.log("音频已解锁");
                        }
                    };
                    
                    // 监听各种用户交互事件
                    const events = ['touchstart', 'click', 'keydown'];
                    events.forEach(event => {
                        document.addEventListener(event, unlockAudio, { once: true });
                    });
                },
                
                // 预加载所有音频
                preloadSounds() {
                    const soundFiles = {
                        teaEffect: 'chayinxiao.mp3',       // 茶效果音效
                        victory: 'shengliyinxiao.mp3',     // 胜利音效
                        gameOver: 'shibaiyinxiao.mp3',     // 失败音效
                        collectCoin: 'shoujijinbi.mp3',    // 收集金币音效
                        bubblePop: 'qipaoposui.mp3',       // 气泡破裂音效
                        fullCollection: 'quanshoujiyinxiao.mp3' // 全收集特殊音效
                    };
                    
                    // 为每个音频创建缓冲池
                    Object.keys(soundFiles).forEach(soundName => {
                        this.bufferPool[soundName] = [];
                        this.loadSound(soundFiles[soundName], soundName);
                    });
                },
                
                // 加载单个音频
                async loadSound(filename, soundName) {
                    try {
                        const response = await fetch(filename);
                        const arrayBuffer = await response.arrayBuffer();
                        const audioBuffer = await this.audioContext.decodeAudioData(arrayBuffer);
                        
                        // 创建多个音频源实例并存入缓冲池
                        for (let i = 0; i < this.bufferSize; i++) {
                            const source = this.audioContext.createBufferSource();
                            source.buffer = audioBuffer;
                            source.connect(this.gainNode);
                            this.bufferPool[soundName].push({
                                source: source,
                                isPlaying: false,
                                lastPlayTime: 0
                            });
                        }
                        
                        console.log(`音频 ${soundName} 加载成功`);
                    } catch (error) {
                        console.error(`加载音频 ${soundName} 失败:`, error);
                    }
                },
                
                // 监控音频上下文状态
                monitorAudioContext() {
                    if (this.audioContext) {
                        // 检查音频上下文状态
                        if (this.audioContext.state === 'suspended') {
                            this.isAudioContextSuspended = true;
                            console.log("音频上下文被挂起，尝试恢复...");
                            this.resumeAudioContext();
                        }
                        
                        // 定期检查音频上下文状态
                        setInterval(() => {
                            if (this.audioContext.state === 'suspended') {
                                this.isAudioContextSuspended = true;
                                this.resumeAudioContext();
                            }
                        }, 5000);
                    }
                },
                
                // 恢复音频上下文
                async resumeAudioContext() {
                    if (this.audioContext && this.audioContext.state === 'suspended') {
                        try {
                            await this.audioContext.resume();
                            this.isAudioContextSuspended = false;
                            console.log("音频上下文已恢复");
                        } catch (error) {
                            console.error("恢复音频上下文失败:", error);
                        }
                    }
                },
                
                // 播放音效
                playSound(soundName) {
                    // 检查音频是否已解锁
                    if (!this.isAudioUnlocked) {
                        console.log("音频未解锁，尝试解锁...");
                        this.addUserInteractionListeners();
                        return;
                    }
                    
                    if (!this.isInitialized || !this.bufferPool[soundName]) return;
                    
                    const now = Date.now();
                    if (now - this.lastPlayTime < this.playInterval) return;
                    
                    // 从缓冲池中获取可用的音频源
                    const availableSource = this.bufferPool[soundName].find(
                        item => !item.isPlaying && (now - item.lastPlayTime > this.playInterval)
                    );
                    
                    if (availableSource) {
                        try {
                            // 如果音频上下文被挂起，尝试恢复
                            if (this.isAudioContextSuspended) {
                                this.resumeAudioContext();
                            }
                            
                            // 创建新的音频源
                            const source = this.audioContext.createBufferSource();
                            source.buffer = availableSource.source.buffer;
                            source.connect(this.gainNode);
                            
                            // 播放音频
                            source.start(0);
                            availableSource.isPlaying = true;
                            availableSource.lastPlayTime = now;
                            this.lastPlayTime = now;
                            
                            // 音频播放完成后重置状态
                            source.onended = () => {
                                availableSource.isPlaying = false;
                            };
                        } catch (error) {
                            console.error(`播放音效 ${soundName} 失败:`, error);
                        }
                    }
                },
                
                // 设置音量
                setVolume(volume) {
                    if (this.gainNode) {
                        this.gainNode.gain.value = volume;
                    }
                }
            };
        })();
    </script>


</body></html>